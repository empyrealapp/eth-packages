{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"api/access_list/","title":"Access List","text":""},{"location":"api/access_list/#eth_rpc.models.AccessList","title":"eth_rpc.models.AccessList","text":"<p>               Bases: <code>RPCModel</code></p>"},{"location":"api/access_list/#eth_rpc.models.AccessList.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/access_list/#eth_rpc.models.AccessList.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/access_list/#eth_rpc.models.AccessList.storage_keys","title":"storage_keys  <code>instance-attribute</code>","text":"<pre><code>storage_keys\n</code></pre>"},{"location":"api/access_list/#eth_rpc.models.AccessList.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/account/","title":"Account","text":""},{"location":"api/account/#eth_rpc.Account","title":"eth_rpc.Account","text":"<p>               Bases: <code>Request</code>, <code>Account</code>, <code>Generic[Network]</code></p>"},{"location":"api/account/#eth_rpc.Account.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.code_hash","title":"code_hash  <code>instance-attribute</code>","text":"<pre><code>code_hash\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.storage_root","title":"storage_root  <code>instance-attribute</code>","text":"<pre><code>storage_root\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.balance","title":"balance  <code>instance-attribute</code>","text":"<pre><code>balance\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.nonce","title":"nonce  <code>instance-attribute</code>","text":"<pre><code>nonce\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.get_balance","title":"get_balance","text":"<pre><code>get_balance(address, block_number='latest')\n</code></pre> Source code in <code>eth_rpc/account.py</code> <pre><code>def get_balance(\n    self, address: HexAddress, block_number: int | BLOCK_STRINGS = \"latest\"\n) -&gt; RPCResponseModel[GetAccountArgs, HexInteger]:\n    return RPCResponseModel(\n        self.rpc().get_balance,\n        GetAccountArgs(\n            address=address,\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.get_account","title":"get_account","text":"<pre><code>get_account(address, block_number='latest')\n</code></pre> Source code in <code>eth_rpc/account.py</code> <pre><code>def get_account(\n    self, address: HexAddress, block_number: int | BLOCK_STRINGS = \"latest\"\n) -&gt; RPCResponseModel[GetAccountArgs, AccountModel]:\n    return RPCResponseModel(\n        self.rpc().get_account,\n        GetAccountArgs(\n            address=address,\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api/block/","title":"Block","text":""},{"location":"api/block/#eth_rpc.Block","title":"eth_rpc.Block","text":"<p>               Bases: <code>Block</code>, <code>Request</code>, <code>Generic[Network]</code></p>"},{"location":"api/block/#eth_rpc.Block.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.hash","title":"hash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hash = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.transactions","title":"transactions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transactions = Field(default_factory=list)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.base_fee_per_gas","title":"base_fee_per_gas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>base_fee_per_gas = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.difficulty","title":"difficulty  <code>instance-attribute</code>","text":"<pre><code>difficulty\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.extra_data","title":"extra_data  <code>instance-attribute</code>","text":"<pre><code>extra_data\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.gas_limit","title":"gas_limit  <code>instance-attribute</code>","text":"<pre><code>gas_limit\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.gas_used","title":"gas_used  <code>instance-attribute</code>","text":"<pre><code>gas_used\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.logs_bloom","title":"logs_bloom  <code>instance-attribute</code>","text":"<pre><code>logs_bloom\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.miner","title":"miner  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>miner = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.mix_hash","title":"mix_hash  <code>instance-attribute</code>","text":"<pre><code>mix_hash\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.nonce","title":"nonce  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nonce = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.parent_hash","title":"parent_hash  <code>instance-attribute</code>","text":"<pre><code>parent_hash\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.receipts_root","title":"receipts_root  <code>instance-attribute</code>","text":"<pre><code>receipts_root\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.sha3_uncles","title":"sha3_uncles  <code>instance-attribute</code>","text":"<pre><code>sha3_uncles\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.state_root","title":"state_root  <code>instance-attribute</code>","text":"<pre><code>state_root\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.total_difficulty","title":"total_difficulty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_difficulty = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.transactions_root","title":"transactions_root  <code>instance-attribute</code>","text":"<pre><code>transactions_root\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.uncles","title":"uncles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uncles = Field(default_factory=list)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.normalize_timestamp","title":"normalize_timestamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normalize_timestamp = field_validator(\n    \"timestamp\", mode=\"before\"\n)(load_datetime_string)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.has_log","title":"has_log","text":"<pre><code>has_log(topic)\n</code></pre> Source code in <code>eth_rpc/models/block.py</code> <pre><code>def has_log(self, topic: HexStr):\n    t = bytes.fromhex(topic.replace(\"0x\", \"\"))\n    return t in BloomFilter(self.logs_bloom)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.compress","title":"compress","text":"<pre><code>compress()\n</code></pre> Source code in <code>eth_rpc/models/block.py</code> <pre><code>def compress(self) -&gt; bytes:\n    return zlib.compress(self.model_dump_json().encode(\"utf-8\"))\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.priority_fee","title":"priority_fee  <code>classmethod</code>","text":"<pre><code>priority_fee()\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef priority_fee(cls) -&gt; RPCResponseModel[NoArgs, HexInteger]:\n    return RPCResponseModel(\n        cls.rpc().max_priority_fee_per_gas,\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.fee_history","title":"fee_history  <code>classmethod</code>","text":"<pre><code>fee_history(\n    block_count=4,\n    lower_percentile=25,\n    upper_percentile=75,\n    block_number=\"latest\",\n)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef fee_history(\n    cls,\n    block_count: int = 4,\n    lower_percentile: int = 25,\n    upper_percentile: int = 75,\n    block_number: BlockReference = \"latest\",\n) -&gt; RPCResponseModel[FeeHistoryArgs, FeeHistory]:\n    return RPCResponseModel(\n        cls.rpc().fee_history,\n        FeeHistoryArgs(\n            block_count=block_count,\n            block_number=block_number,\n            percentiles=[\n                lower_percentile,\n                upper_percentile,\n            ],\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.get_block_transaction_count","title":"get_block_transaction_count  <code>classmethod</code>","text":"<pre><code>get_block_transaction_count(block_number)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef get_block_transaction_count(\n    cls, block_number: HexInteger\n) -&gt; RPCResponseModel[BlockNumberArg, int]:\n    return RPCResponseModel(\n        cls.rpc().get_block_tx_count_by_number,\n        BlockNumberArg(\n            block_number=block_number,\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.load_by_number","title":"load_by_number  <code>classmethod</code>","text":"<pre><code>load_by_number(block_number, with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef load_by_number(\n    cls,\n    block_number: int | HexInteger | BLOCK_STRINGS,\n    with_tx_data: bool = False,\n) -&gt; RPCResponseModel[GetBlockByNumberArgs, \"Block[Network]\"]:\n    return RPCResponseModel(\n        cls.rpc().get_block_by_number,\n        GetBlockByNumberArgs(\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n            with_tx_data=with_tx_data,\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.get_number","title":"get_number  <code>classmethod</code>","text":"<pre><code>get_number()\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef get_number(cls) -&gt; RPCResponseModel[NoArgs, HexInteger]:\n    return RPCResponseModel(\n        cls.rpc().block_number,\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.load_by_datetime","title":"load_by_datetime  <code>async</code> <code>classmethod</code>","text":"<pre><code>load_by_datetime(\n    when, low=None, high=None, apprx_block_time=12\n)\n</code></pre> <p>Searches for a block, finding the first block before a datetime. Recursively searches, using low and high as the boundaries for the binary search.</p> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def load_by_datetime(\n    cls,\n    when: datetime,\n    low: int | None = None,\n    high: int | None = None,\n    apprx_block_time=12,\n) -&gt; \"Block[Network]\":\n    \"\"\"\n    Searches for a block, finding the first block before a datetime.\n    Recursively searches, using low and high as the boundaries for the binary search.\n    \"\"\"\n    Network = cls._network\n    if not when.tzinfo:\n        when = when.replace(tzinfo=timezone.utc)\n    if not (low and high):\n        now = datetime.now(timezone.utc)\n        diff = now - when\n        day_diff = diff.days\n        seconds_diff = day_diff * 24 * 3600\n        block_number = await cls[Network].get_number()  # type: ignore\n        if not low:\n            low = int(\n                max(block_number - (seconds_diff / (apprx_block_time * 0.8)), 0)\n            )\n        if not high:\n            high = int(\n                min(\n                    block_number - (seconds_diff / (apprx_block_time * 1.2)),\n                    block_number,\n                )\n            )\n    if when &lt; datetime(\n        year=2015,\n        month=7,\n        day=30,\n        hour=3,\n        minute=26,\n        second=13,\n        tzinfo=timezone.utc,\n    ):\n        raise ValueError(\"Block before genesis\")\n\n    if high &gt; low:\n        mid = (high + low) // 2\n        mid_block = await cls[Network].load_by_number(mid)  # type: ignore\n\n        if mid_block.timestamp == when:\n            return mid_block\n        elif mid_block.timestamp &gt; when:\n            return await cls[Network].load_by_datetime(when, low, mid - 1)  # type: ignore\n        else:\n            return await cls[Network].load_by_datetime(when, mid + 1, high)  # type: ignore\n    return await cls[Network].load_by_number(high)  # type: ignore\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.latest","title":"latest  <code>classmethod</code>","text":"<pre><code>latest(with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef latest(\n    cls, with_tx_data: bool = False\n) -&gt; RPCResponseModel[GetBlockByNumberArgs, \"Block[Network]\"]:\n    return cls.load_by_number(\"latest\", with_tx_data=with_tx_data)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.pending","title":"pending  <code>classmethod</code>","text":"<pre><code>pending(with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef pending(\n    cls, with_tx_data: bool = False\n) -&gt; RPCResponseModel[GetBlockByNumberArgs, \"Block[Network]\"]:\n    return cls.load_by_number(\"pending\", with_tx_data=with_tx_data)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.load_by_hash","title":"load_by_hash  <code>classmethod</code>","text":"<pre><code>load_by_hash(block_hash, with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef load_by_hash(\n    cls, block_hash: HexStr, with_tx_data: bool = False\n) -&gt; RPCResponseModel[GetBlockByHashArgs, \"Block[Network]\"]:\n    return RPCResponseModel(\n        cls.rpc().get_block_by_hash,\n        GetBlockByHashArgs(\n            block_hash=block_hash,\n            with_tx_data=with_tx_data,\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.subscribe_from","title":"subscribe_from  <code>async</code> <code>classmethod</code>","text":"<pre><code>subscribe_from(start_block=None, with_tx_data=True)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def subscribe_from(\n    cls,\n    start_block: int | None = None,\n    with_tx_data: bool = True,\n) -&gt; AsyncIterator[\"Block[Network]\"]:\n    queue = asyncio.Queue[Block[Network]]()\n    should_publish_blocks = asyncio.Event()\n    asyncio.create_task(\n        cls.listen(\n            queue=queue,\n            publish_blocks=should_publish_blocks,\n            with_tx_data=with_tx_data,\n        )\n    )\n    latest = await cls.latest()\n    if not start_block:\n        start_block = latest.number\n    assert start_block\n\n    # NOTE: you pull latest twice because there can be a backfill while you're populating\n    for num in range(start_block, latest.number + 1):\n        yield await cls.load_by_number(num, with_tx_data=with_tx_data)\n\n    should_publish_blocks.set()\n    while True:\n        block = await queue.get()\n        if block.number &gt; latest.number:\n            yield block\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.listen","title":"listen  <code>async</code> <code>classmethod</code>","text":"<pre><code>listen(\n    *,\n    queue,\n    publish_blocks=DEFAULT_EVENT,\n    with_tx_data=True,\n    subscription_type=\"newHeads\"\n)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def listen(\n    cls,\n    *,\n    # TODO: typehinting this is tricky because the type of the Queue is conditional based on the subscription type\n    queue: asyncio.Queue,\n    publish_blocks: asyncio.Event = DEFAULT_EVENT,\n    with_tx_data: bool = True,\n    subscription_type: SUBSCRIPTION_TYPE = \"newHeads\",\n):\n    internal_queue: asyncio.Queue = asyncio.Queue()\n    flush_queue: bool = True\n    async for block in cls._listen(\n        with_tx_data=with_tx_data, subscription_type=subscription_type\n    ):\n        if publish_blocks.is_set():\n            if flush_queue:\n                while not internal_queue.empty():\n                    staged_block = await internal_queue.get()\n                    await queue.put(staged_block)\n                flush_queue = False\n            await queue.put(block)\n        else:\n            await internal_queue.put(block)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.convert","title":"convert  <code>async</code> <code>classmethod</code>","text":"<pre><code>convert(block_value)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def convert(cls, block_value: BLOCK_STRINGS | int) -&gt; int:\n    if isinstance(block_value, int):\n        return block_value\n    block = await cls.load_by_number(block_value)\n    return block.number\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.decompress","title":"decompress  <code>classmethod</code>","text":"<pre><code>decompress(raw_bytes)\n</code></pre> <p>Convert gzip compressed block to a Block</p> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef decompress(cls, raw_bytes: bytes) -&gt; \"Block\":\n    \"\"\"Convert gzip compressed block to a Block\"\"\"\n    return Block.model_validate_json(zlib.decompress(raw_bytes))\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.parent_block","title":"parent_block","text":"<pre><code>parent_block()\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>def parent_block(self) -&gt; RPCResponseModel[GetBlockByHashArgs, \"Block[Network]\"]:\n    return self.load_by_hash(self.parent_hash)\n</code></pre>"},{"location":"api/contract/","title":"Contract","text":""},{"location":"api/contract/#eth_rpc.Contract","title":"eth_rpc.Contract","text":"<p>               Bases: <code>ContractT</code>, <code>Request</code></p>"},{"location":"api/contract/#eth_rpc.Contract.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/contract_func/","title":"ContractFunc","text":""},{"location":"api/contract_func/#eth_rpc.ContractFunc","title":"eth_rpc.ContractFunc  <code>dataclass</code>","text":"<pre><code>ContractFunc(\n    func, contract, data=HexStr(\"0x\"), _network=None\n)\n</code></pre> <p>               Bases: <code>Generic[T, U]</code></p>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.contract","title":"contract  <code>instance-attribute</code>","text":"<pre><code>contract\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data = HexStr('0x')\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.address","title":"address  <code>property</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.alias","title":"alias  <code>property</code>","text":"<pre><code>alias\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.encode","title":"encode","text":"<pre><code>encode()\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def encode(self):\n    return bytes.fromhex(self.data[2:])\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.decode","title":"decode","text":"<pre><code>decode(result)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def decode(self, result: bytes) -&gt; U:\n    return self.func.decode_result(HexStr(result.hex()))\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.estimate_gas","title":"estimate_gas","text":"<pre><code>estimate_gas(\n    *, from_=None, block_number=\"latest\", sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def estimate_gas(\n    self,\n    *,\n    from_: Optional[HexAddress] = None,\n    block_number: HexInteger | Literal[\"latest\", \"pending\"] = \"latest\",\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexInteger]:\n    return run(\n        self._estimate_gas, from_=from_, block_number=block_number, sync=sync\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.access_list","title":"access_list","text":"<pre><code>access_list(\n    *,\n    gas=10000000,\n    sender=ADDRESS_ZERO,\n    block_number=None,\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def access_list(\n    self,\n    *,\n    gas: int = 10000000,\n    sender: HexAddress = ADDRESS_ZERO,\n    block_number: int | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[AccessListResponse]:\n    return run(\n        self._access_list,\n        gas=gas,\n        sender=sender,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.call","title":"call","text":"<pre><code>call(\n    *,\n    from_=None,\n    block_number=\"latest\",\n    value=0,\n    state_diff={},\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def call(\n    self,\n    *,\n    from_: Optional[HexAddress] = None,\n    block_number: int | BLOCK_STRINGS = \"latest\",\n    value: HexInteger | int = 0,\n    state_diff: dict[HexAddress, Any] = {},\n    sync: bool = False,\n) -&gt; MaybeAwaitable[EthResponse[T, U]]:\n    return run(self._call, from_, block_number, value, state_diff, sync=sync)\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.get","title":"get","text":"<pre><code>get(\n    *,\n    from_=None,\n    block_number=\"latest\",\n    value=0,\n    state_diff={},\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def get(\n    self,\n    *,\n    from_: Optional[HexAddress] = None,\n    block_number: int | BLOCK_STRINGS = \"latest\",\n    value: HexInteger | int = 0,\n    state_diff: dict[HexAddress, Any] = {},\n    sync: bool = False,\n) -&gt; MaybeAwaitable[U]:\n    return run(\n        self._get,\n        from_=from_,\n        block_number=block_number,\n        value=value,\n        state_diff=state_diff,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.prepare","title":"prepare","text":"<pre><code>prepare(\n    wallet,\n    *,\n    nonce=None,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    use_access_list=False,\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def prepare(\n    self,\n    wallet: \"BaseWallet\",\n    *,\n    nonce: Optional[int] = None,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    use_access_list: bool = False,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[PreparedTransaction]:\n    return run(\n        self._prepare,\n        wallet,\n        nonce=nonce,\n        value=value,\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        use_access_list=use_access_list,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.execute","title":"execute","text":"<pre><code>execute(\n    wallet,\n    *,\n    nonce=None,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    use_access_list=False,\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def execute(\n    self,\n    wallet: \"BaseWallet\",\n    *,\n    nonce: Optional[int] = None,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    use_access_list: bool = False,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._execute,\n        wallet,\n        nonce=nonce,\n        value=value,\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        use_access_list=use_access_list,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/event/","title":"Event","text":""},{"location":"api/event/#eth_rpc.Event","title":"eth_rpc.Event","text":"<p>               Bases: <code>Request</code>, <code>Generic[T]</code></p>"},{"location":"api/event/#eth_rpc.Event.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.anonymous","title":"anonymous  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anonymous = False\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.topic1_filter","title":"topic1_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic1_filter = IGNORE_VAL\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.topic2_filter","title":"topic2_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic2_filter = IGNORE_VAL\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.topic3_filter","title":"topic3_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic3_filter = IGNORE_VAL\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.addresses_filter","title":"addresses_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>addresses_filter = []\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_topic0","title":"get_topic0  <code>cached</code> <code>property</code>","text":"<pre><code>get_topic0\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.subscribe","title":"subscribe  <code>property</code>","text":"<pre><code>subscribe\n</code></pre> <p>This returns a callable for the async subscriber, allowing you to select the network for the subscription, ie.</p> <pre><code>my_event = Event[EventType](name=\"MyEvent\")\nasync for event in my_event.subscribe[Ethereum]():\n    ...\n</code></pre> <p>If no network is provided, it will use the default network.</p>"},{"location":"api/event/#eth_rpc.Event.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def model_post_init(self, __context) -&gt; None:\n    EventType, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    self._output_type = EventType\n    return super().model_post_init(__context)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.match_topics","title":"match_topics","text":"<pre><code>match_topics(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def match_topics(self, log: Log) -&gt; bool:\n    # TODO: addresses_filter\n    if len(log.topics) == 0:\n        return False\n    if log.topics[0] != self.get_topic0:\n        return False\n    if self.topic1_filter != IGNORE_VAL and len(log.topics) &gt;= 2:\n        if not self._matches(log.topics[1], self.topic1_filter):\n            return False\n    if self.topic2_filter != IGNORE_VAL and len(log.topics) &gt;= 3:\n        if not self._matches(log.topics[2], self.topic2_filter):\n            return False\n    if self.topic3_filter != IGNORE_VAL and len(log.topics) &gt;= 4:\n        if not self._matches(log.topics[3], self.topic3_filter):\n            return False\n    return True\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.match_address","title":"match_address","text":"<pre><code>match_address(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def match_address(self, log: Log) -&gt; bool:\n    if self.addresses_filter:\n        return log.address in self.addresses_filter\n    return True\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.match","title":"match","text":"<pre><code>match(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def match(self, log: Log) -&gt; bool:\n    return self.match_address(log) and self.match_topics(log)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.add_address","title":"add_address","text":"<pre><code>add_address(address)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def add_address(self, address: HexAddress | list[HexAddress]):\n    if isinstance(address, list):\n        for addr in address:\n            self.add_address(addr)\n    else:\n        if address not in self.addresses_filter:\n            self.addresses_filter.append(address)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.remove_address","title":"remove_address","text":"<pre><code>remove_address(address)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def remove_address(self, address: HexAddress):\n    self.addresses_filter = [\n        _address for _address in self.addresses_filter if _address != address\n    ]\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.process_value","title":"process_value  <code>staticmethod</code>","text":"<pre><code>process_value(type_name, v)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>@staticmethod\ndef process_value(type_name, v: str):\n    # strip prefix if necessary\n    if \"0x\" in v:\n        v = v[2:]\n\n    if type_name == \"address\":\n        # last 20 bytes of value\n        return \"0x{}\".format(v[-40:])\n    if \"bytes\" in type_name:\n        return bytes.fromhex(v)\n    if \"uint\" in type_name:\n        return int.from_bytes(bytes.fromhex(v), \"big\", signed=False)\n    elif \"int\" in type_name:\n        return int.from_bytes(bytes.fromhex(v), \"big\", signed=True)\n    if type_name == \"bool\":\n        return v[-1] == \"1\"\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.from_dict","title":"from_dict","text":"<pre><code>from_dict(fields)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def from_dict(self, fields: dict[str, Any]):\n    EventType, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    return EventType(**fields)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.process_log","title":"process_log","text":"<pre><code>process_log(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def process_log(self, log: Log) -&gt; EventData[T]:\n    return EventData(\n        name=self.name,\n        log=log,\n        event=self.process(log.topics, log.data),\n        network=self._network or get_current_network(),\n    )\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.process","title":"process","text":"<pre><code>process(topics, data)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def process(self, topics: list[HexStr], data: HexStr) -&gt; T:\n    EventType, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    indexed = self.get_indexed()\n    try:\n        indexed_dict = {\n            name: self.process_value(type_, topics[i + 1])\n            for i, (name, type_) in enumerate(indexed)\n        }\n    except IndexError:\n        raise LogDecodeError(\"Mismatched Indexed values\")\n\n    unindexed = self.get_unindexed()\n    try:\n        unindexed_values = decode(\n            [type_ for (_, type_) in unindexed], bytes.fromhex(data[2:])\n        )\n    except InsufficientDataBytes:\n        raise LogDecodeError(\"Mismatched Unindexed values\")\n\n    return EventType(\n        **indexed_dict\n        | {name: val for (name, _), val in zip(unindexed, unindexed_values)}\n    )\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_indexed","title":"get_indexed","text":"<pre><code>get_indexed()\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def get_indexed(self):\n    inputs, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    input_types = inputs.model_fields\n    results = []\n    for name, field in input_types.items():\n        indexed = False\n        _type = field.annotation\n        annotations = field.metadata\n        for annotation in annotations:\n            if annotation == Indexed:\n                indexed = True\n            elif isinstance(annotation, Name):\n                name = annotation.value\n        if indexed:\n            results.append((name, map_type(_type)))\n    return results\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_unindexed","title":"get_unindexed","text":"<pre><code>get_unindexed()\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def get_unindexed(self):\n    inputs, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    input_types = inputs.model_fields\n    results = []\n    for name, field in input_types.items():\n        indexed = False\n        _type = field.annotation\n        annotations = field.metadata\n        for annotation in annotations:\n            if annotation == Indexed:\n                indexed = True\n            elif isinstance(annotation, Name):\n                name = annotation.value\n        if not indexed:\n            results.append((name, convert(_type)))\n    return results\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.set_filter","title":"set_filter","text":"<pre><code>set_filter(\n    addresses=[],\n    topic1=IGNORE_VAL,\n    topic2=IGNORE_VAL,\n    topic3=IGNORE_VAL,\n)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def set_filter(\n    self,\n    addresses: list[HexAddress] = [],\n    topic1: Optional[HexStr | list[HexStr]] | IGNORE = IGNORE_VAL,\n    topic2: Optional[HexStr | list[HexStr]] | IGNORE = IGNORE_VAL,\n    topic3: Optional[HexStr | list[HexStr]] | IGNORE = IGNORE_VAL,\n):\n    model = deepcopy(self)\n    model.addresses_filter = addresses\n    if topic1 != IGNORE_VAL:\n        model.topic1_filter = topic1\n    if topic2 != IGNORE_VAL:\n        model.topic1_filter = model.topic1_filter or None\n        model.topic2_filter = topic2\n    if topic3 != IGNORE_VAL:\n        model.topic1_filter = model.topic1_filter or None\n        model.topic2_filter = model.topic2_filter or None\n        model.topic3_filter = topic3\n    return model\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_logs","title":"get_logs  <code>async</code>","text":"<pre><code>get_logs(start_block, end_block)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>async def get_logs(\n    self,\n    start_block: BlockReference | int,\n    end_block: BlockReference | int,\n) -&gt; AsyncIterator[EventData[T]]:\n    cur_end = end_block\n    try:\n        response = await self._get_logs(\n            start_block,\n            cur_end,\n            self.addresses_filter,\n            topic1=self.topic1_filter,\n            topic2=self.topic2_filter,\n            topic3=self.topic3_filter,\n        )\n    except ValueError as err:\n        message = err.args[0]\n        if \"Log response size exceeded.\" in message:\n            boundaries = re.findall(\"0x[0-9a-f]+\", message)\n            raise LogResponseExceededError(\n                err.args[0], int(boundaries[0], 16), int(boundaries[1], 16)\n            )\n        raise err\n\n    for result in response:\n        # TODO: this is just a placeholder\n        if len(result.topics) != (len(self.get_indexed()) + 1):\n            # this happens when an event has the same topic0, but different indexed events so it doesn't match up to the expected ABI\n            continue\n\n        event_data = EventData[T](\n            name=self.name,\n            log=result,\n            event=self.process(\n                result.topics,\n                result.data,\n            ),\n            network=self._network or get_current_network(),\n        )\n        yield event_data\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.backfill","title":"backfill  <code>async</code>","text":"<pre><code>backfill(start_block=None, end_block=None, step_size=None)\n</code></pre> <p>This backfills events, handling LogResponseExceededError to provide all logs in a range too large for a single request</p> Source code in <code>eth_rpc/event.py</code> <pre><code>async def backfill(\n    self,\n    start_block: int | None = None,\n    end_block: int | None = None,\n    step_size: Optional[int] = None,\n) -&gt; AsyncIterator[EventData[T]]:\n    \"\"\"\n    This backfills events, handling LogResponseExceededError to provide all logs in a range too large for a single request\n    \"\"\"\n    start_block = start_block or 1\n    current_number = await Block.get_number()\n    end_block = end_block or (current_number - 3)  # set 3 default confirmations\n\n    if start_block == \"earliest\":\n        cur_start = 0\n    else:\n        cur_start = start_block\n\n    if step_size:\n        cur_end = cur_start + step_size\n    else:\n        cur_end = end_block\n    while cur_start &lt;= end_block:\n        try:\n            async for log in self.get_logs(\n                start_block=cur_start,\n                end_block=min(cur_end, end_block),\n            ):\n                yield log\n        except LogResponseExceededError as err:\n            cur_end = err.recommended_end\n            continue\n        cur_start = cur_end + 1\n        if step_size:\n            cur_end += step_size\n        else:\n            cur_end = end_block\n</code></pre>"},{"location":"api/event_data/","title":"EventData","text":""},{"location":"api/event_data/#eth_rpc.EventData","title":"eth_rpc.EventData","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>This joins a log with it's transformed format (T). It needs to be in models because Models rely on Types.</p>"},{"location":"api/event_data/#eth_rpc.EventData.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.network","title":"network  <code>instance-attribute</code>","text":"<pre><code>network\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.tx","title":"tx  <code>property</code>","text":"<pre><code>tx\n</code></pre>"},{"location":"api/func/","title":"FuncSignature","text":""},{"location":"api/func/#eth_rpc.FuncSignature","title":"eth_rpc.FuncSignature","text":"<p>               Bases: <code>Request</code>, <code>Generic[T, U]</code></p>"},{"location":"api/func/#eth_rpc.FuncSignature.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias = None\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_identifier","title":"get_identifier","text":"<pre><code>get_identifier()\n</code></pre> <p>This works most of the time</p> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_identifier(self):\n    \"\"\"This works most of the time\"\"\"\n    signature = f'{self.name}({\",\".join(self.get_inputs())})'\n    return f\"0x{keccak_256(signature.encode('utf-8')).hex()[:8]}\"\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_inputs","title":"get_inputs","text":"<pre><code>get_inputs()\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_inputs(self):\n    from ..types import Struct\n\n    inputs, _ = self.__pydantic_generic_metadata__[\"args\"]\n    if inputs is NoArgs:\n        return []\n    if (\n        type(inputs) is not GenericAlias\n        and isclass(inputs)\n        and issubclass(inputs, BaseModel)\n    ):\n        converted_inputs = transform_primitive(inputs)\n        if issubclass(inputs, Struct):\n            converted_input_tuple = \",\".join(converted_inputs)\n            return [f\"({converted_input_tuple})\"]\n    else:\n        if get_origin(inputs) == list:\n            return [transform_primitive(inputs)]\n        elif get_origin(inputs) == tuple:\n            return tuple(transform_primitive(input) for input in get_args(inputs))\n        else:\n            converted_inputs = transform_primitive(inputs)\n    if not isinstance(converted_inputs, list):\n        return [converted_inputs]\n    return converted_inputs\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_output","title":"get_output","text":"<pre><code>get_output()\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_output(self):\n    outputs = self._output\n    if outputs is type(None):\n        return None\n\n    if is_annotation(outputs):\n        outputs = get_args(outputs)[0]\n\n    if (\n        isclass(outputs)\n        and not isinstance(outputs, GenericAlias)\n        and issubclass(outputs, BaseModel)\n    ):\n        converted_outputs = transform_primitive(outputs)\n    else:\n        converted_outputs = transform_primitive(outputs)\n    return converted_outputs\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_output_name","title":"get_output_name","text":"<pre><code>get_output_name()\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_output_name(self):\n    return [self._get_name(output) for output in get_args(self._output)]\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.encode_call","title":"encode_call","text":"<pre><code>encode_call(*, inputs)\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def encode_call(self, *, inputs: T) -&gt; HexStr:\n    from ..types import Struct\n\n    identifier = self.get_identifier()\n    # TODO: this is hard\n    if inputs == ():\n        return identifier\n\n    if isinstance(inputs, BaseModel):\n        if isinstance(inputs, Struct):\n            input_data = inputs.to_bytes().hex()\n        else:\n            input_data = encode(\n                self.get_inputs(),\n                list(inputs.model_dump().values()),\n            ).hex()\n    elif not isinstance(inputs, tuple):\n        input_data = encode(self.get_inputs(), [inputs]).hex()\n    else:\n        input_data = encode(self.get_inputs(), inputs).hex()\n    return HexStr(f\"{identifier}{input_data}\")\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.decode_result","title":"decode_result","text":"<pre><code>decode_result(result)\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def decode_result(self, result: HexStr) -&gt; U:\n    output = self.get_output()\n    if output is None:\n        # return None if the expected return type is None\n        return output  # type: ignore\n\n    if not isinstance(output, list):\n        output = [output]\n        decoded_output = decode(output, bytes.fromhex(result.removeprefix(\"0x\")))[0]\n    else:\n        if isclass(self._output) and issubclass(self._output, Struct):\n            return self._output.from_bytes(bytes.fromhex(result.removeprefix(\"0x\")))\n        else:\n            decoded_output = decode(\n                output, bytes.fromhex(result.removeprefix(\"0x\"))\n            )\n\n    # NOTE: https://github.com/pydantic/pydantic/discussions/5970\n    # TODO: this is discussed to see if its a bug or not.  Annotations are a class but can't be checked as a subclass\n    if (\n        isclass(self._output)\n        and not isinstance(self._output, GenericAlias)\n        and issubclass(self._output, BaseModel)\n    ):\n        init_dict = {}\n        for (key, field_info), val in zip(\n            self._output.model_fields.items(), decoded_output\n        ):\n            init_dict[field_info.alias or key] = val\n        return self._output(**init_dict)  # type: ignore\n    return decoded_output\n</code></pre>"},{"location":"api/log/","title":"Log","text":""},{"location":"api/log/#eth_rpc.Log","title":"eth_rpc.Log","text":"<p>               Bases: <code>Request</code>, <code>Log</code></p>"},{"location":"api/log/#eth_rpc.Log.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.transaction_hash","title":"transaction_hash  <code>instance-attribute</code>","text":"<pre><code>transaction_hash\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.block_hash","title":"block_hash  <code>instance-attribute</code>","text":"<pre><code>block_hash\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.block_number","title":"block_number  <code>instance-attribute</code>","text":"<pre><code>block_number\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.log_index","title":"log_index  <code>instance-attribute</code>","text":"<pre><code>log_index\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.removed","title":"removed  <code>instance-attribute</code>","text":"<pre><code>removed\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.topics","title":"topics  <code>instance-attribute</code>","text":"<pre><code>topics\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.transaction_index","title":"transaction_index  <code>instance-attribute</code>","text":"<pre><code>transaction_index\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.load_by_number","title":"load_by_number  <code>classmethod</code>","text":"<pre><code>load_by_number(from_block, to_block=None)\n</code></pre> Source code in <code>eth_rpc/log.py</code> <pre><code>@classmethod\ndef load_by_number(\n    self,\n    from_block: int | HexInt,\n    to_block: int | HexInt | None = None,\n) -&gt; RPCResponseModel[LogsArgs, list[\"LogModel\"]]:\n    return RPCResponseModel(\n        self.rpc().get_logs,\n        LogsArgs(\n            params=LogsParams(\n                from_block=HexInt(from_block),\n                to_block=HexInt(to_block or from_block + 1),\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.listen","title":"listen  <code>async</code> <code>classmethod</code>","text":"<pre><code>listen(*, queue, publish_logs=DEFAULT_EVENT)\n</code></pre> Source code in <code>eth_rpc/log.py</code> <pre><code>@classmethod\nasync def listen(\n    cls,\n    *,\n    queue: asyncio.Queue[\"LogModel\"],\n    publish_logs: asyncio.Event = DEFAULT_EVENT,\n):\n    internal_queue: asyncio.Queue = asyncio.Queue()\n    flush_queue: bool = True\n    async for log in cls._listen():\n        if publish_logs.is_set():\n            if flush_queue:\n                while not internal_queue.empty():\n                    staged_block = await internal_queue.get()\n                    await queue.put(staged_block)\n                flush_queue = False\n            await queue.put(log)\n        else:\n            await internal_queue.put(log)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.subscribe_from","title":"subscribe_from  <code>async</code> <code>classmethod</code>","text":"<pre><code>subscribe_from(start_block=None, batch_size=50)\n</code></pre> Source code in <code>eth_rpc/log.py</code> <pre><code>@classmethod\nasync def subscribe_from(\n    self,\n    start_block: int | None = None,\n    batch_size: int = 50,\n) -&gt; AsyncIterator[LogModel]:\n    queue = asyncio.Queue[LogModel]()\n    should_publish_logs = asyncio.Event()\n    asyncio.create_task(\n        self.listen(\n            queue=queue,\n            publish_logs=should_publish_logs,\n        )\n    )\n    latest = await Block.get_number()\n    if not start_block:\n        start_block = latest\n    assert start_block\n\n    num = start_block\n    while num &lt;= latest:\n        batch_end = min(num + batch_size, latest)\n        for log in await self.load_by_number(num, batch_end):\n            yield log\n        num += batch_size\n\n    should_publish_logs.set()\n    while True:\n        log = await queue.get()\n        if log.block_number &gt; latest:\n            yield log\n</code></pre>"},{"location":"api/network/","title":"Network","text":""},{"location":"api/network/#eth_rpc.types.Network","title":"eth_rpc.types.Network","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/network/#eth_rpc.types.Network.http","title":"http  <code>class-attribute</code>","text":"<pre><code>http\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.wss","title":"wss  <code>class-attribute</code>","text":"<pre><code>wss\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.chain_id","title":"chain_id  <code>class-attribute</code>","text":"<pre><code>chain_id\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.native_currency","title":"native_currency  <code>class-attribute</code>","text":"<pre><code>native_currency\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.rpc","title":"rpc  <code>class-attribute</code>","text":"<pre><code>rpc\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.block_explorer","title":"block_explorer  <code>class-attribute</code>","text":"<pre><code>block_explorer\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.alchemy_str","title":"alchemy_str  <code>class-attribute</code>","text":"<pre><code>alchemy_str = None\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.multicall3","title":"multicall3  <code>class-attribute</code>","text":"<pre><code>multicall3 = HexAddress(\n    HexStr(\"0xca11bde05977b3631167028862be2a173976ca11\")\n)\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.ens_registry","title":"ens_registry  <code>class-attribute</code>","text":"<pre><code>ens_registry = HexAddress(\n    HexStr(\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\")\n)\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.ens_universal_resolver","title":"ens_universal_resolver  <code>class-attribute</code>","text":"<pre><code>ens_universal_resolver = HexAddress(\n    HexStr(\"0xce01f8eee7E479C928F8919abD53E553a36CeF67\")\n)\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.apprx_block_time","title":"apprx_block_time  <code>class-attribute</code>","text":"<pre><code>apprx_block_time = 12.0\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.set","title":"set  <code>classmethod</code>","text":"<pre><code>set(http=None, wss=None, api_key=None)\n</code></pre> Source code in <code>eth_rpc/types/network.py</code> <pre><code>@classmethod\ndef set(\n    cls,\n    http: str | None = None,\n    wss: str | None = None,\n    api_key: str | None = None,\n):\n    if http:\n        cls.rpc.default.http = Url(http)\n        cls.http = str(cls.rpc.default.http)\n    if wss:\n        cls.rpc.default.wss = Url(wss)\n        cls.wss = str(cls.rpc.default.wss)\n    if api_key:\n        cls.block_explorer.api_key = api_key\n    return cls\n</code></pre>"},{"location":"api/protocol/","title":"ProtocolBase","text":""},{"location":"api/protocol/#eth_rpc.ProtocolBase","title":"eth_rpc.ProtocolBase","text":"<pre><code>ProtocolBase(**kwargs)\n</code></pre> <p>               Bases: <code>_ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/transaction/","title":"Transaction","text":""},{"location":"api/transaction/#eth_rpc.Transaction","title":"eth_rpc.Transaction","text":"<p>               Bases: <code>Request</code>, <code>Transaction</code>, <code>Generic[Network]</code></p>"},{"location":"api/transaction/#eth_rpc.Transaction.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.hash","title":"hash  <code>instance-attribute</code>","text":"<pre><code>hash\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.access_list","title":"access_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>access_list = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.chain_id","title":"chain_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chain_id = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.from_","title":"from_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>from_ = Field(alias='from')\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.gas","title":"gas  <code>instance-attribute</code>","text":"<pre><code>gas\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.gas_price","title":"gas_price  <code>instance-attribute</code>","text":"<pre><code>gas_price\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.max_fee_per_gas","title":"max_fee_per_gas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_fee_per_gas = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.max_priority_fee_per_gas","title":"max_priority_fee_per_gas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_priority_fee_per_gas = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.nonce","title":"nonce  <code>instance-attribute</code>","text":"<pre><code>nonce\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.r","title":"r  <code>instance-attribute</code>","text":"<pre><code>r\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.s","title":"s  <code>instance-attribute</code>","text":"<pre><code>s\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.v","title":"v  <code>instance-attribute</code>","text":"<pre><code>v\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.to","title":"to  <code>instance-attribute</code>","text":"<pre><code>to\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.y_parity","title":"y_parity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_parity = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.block_hash","title":"block_hash  <code>instance-attribute</code>","text":"<pre><code>block_hash\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.block_number","title":"block_number  <code>instance-attribute</code>","text":"<pre><code>block_number\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.transaction_index","title":"transaction_index  <code>instance-attribute</code>","text":"<pre><code>transaction_index\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_block","title":"get_block","text":"<pre><code>get_block(with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/models/transaction.py</code> <pre><code>def get_block(self, with_tx_data: bool = False):\n    from eth_rpc.block import Block\n\n    \"\"\"Load a block hash\"\"\"\n\n    return Block.load_by_hash(self.block_hash, with_tx_data=with_tx_data)\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_by_hash","title":"get_by_hash  <code>classmethod</code>","text":"<pre><code>get_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, Optional[\"Transaction[Network]\"]]:\n    return RPCResponseModel(\n        self.rpc().get_tx_by_hash,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_pending_by_hash","title":"get_pending_by_hash  <code>classmethod</code>","text":"<pre><code>get_pending_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_pending_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, PendingTransaction]:\n    return RPCResponseModel(\n        self.rpc().get_pending_tx_by_hash,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_receipt_by_hash","title":"get_receipt_by_hash  <code>classmethod</code>","text":"<pre><code>get_receipt_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_receipt_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, \"Transaction[Network]\"]:\n    return RPCResponseModel(\n        self.rpc().get_tx_receipt,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_by_index","title":"get_by_index  <code>classmethod</code>","text":"<pre><code>get_by_index(\n    transaction_index, block_hash=None, block_number=None\n)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_by_index(\n    self,\n    transaction_index: int,\n    block_hash: HexStr | None = None,\n    block_number: int | BLOCK_STRINGS | None = None,\n) -&gt; RPCResponseModel[\n    GetTransactionByBlockHash | GetTransactionByBlockNumber, \"Transaction[Network]\"\n]:\n    if block_hash is None and block_number is None:\n        raise ValueError(\"Must provide either block_hash or block_number\")\n    if block_hash:\n        return RPCResponseModel(\n            self.rpc().get_tx_by_block_hash,\n            GetTransactionByBlockHash(\n                block_hash=block_hash,\n                index=HexInteger(transaction_index),\n            ),\n        )\n    block_number = cast(int | BLOCK_STRINGS, block_number)\n    return RPCResponseModel(\n        self.rpc().get_tx_by_block_number,\n        GetTransactionByBlockNumber(\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n            index=HexInteger(transaction_index),\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.subscribe_pending","title":"subscribe_pending  <code>async</code> <code>classmethod</code>","text":"<pre><code>subscribe_pending()\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\nasync def subscribe_pending(  # noqa: C901\n    self,\n) -&gt; AsyncIterator[PendingTransaction]:  # noqa: C901\n    rpc = _force_get_global_rpc()\n    async for w3_connection in connect(\n        rpc.wss,\n        ping_interval=60,\n        ping_timeout=60,\n        max_queue=10000,\n        open_timeout=30,\n    ):\n        try:\n            await self._send_subscription_request(\n                w3_connection,\n            )\n            subscription_response: SubscriptionResponse = json.loads(\n                await w3_connection.recv()\n            )\n            if not subscription_response[\"result\"]:\n                raise ValueError(subscription_response)\n        except Exception as e:\n            raise e\n\n        while True:\n            try:\n                message = await asyncio.wait_for(w3_connection.recv(), timeout=32.0)\n                message_json: JsonPendingWssResponse = json.loads(message)\n                if \"params\" not in message_json:\n                    raise ValueError(message_json)\n\n                transaction_hash: HexStr = message_json[\"params\"][\"result\"]\n                transaction = await self.get_pending_by_hash(transaction_hash)\n                if transaction:\n                    yield transaction\n            except asyncio.exceptions.TimeoutError:\n                pass\n            except (\n                ConnectionClosedError,\n                ConnectionResetError,\n                OSError,  # No route to host\n                asyncio.exceptions.IncompleteReadError,  # TODO: should this be handled differently?\n            ) as err:\n                logger.error(\"connection terminated unexpectedly: %s\", err)\n                await asyncio.sleep(1)\n                # we're in an iterator, so make a new connection and continue listening\n                break\n            except Exception as err:\n                logger.error(\"unknown connection error: %s\", err)\n                await asyncio.sleep(1)\n                # we're in an iterator, so make a new connection and continue listening\n                break\n</code></pre>"},{"location":"api/transaction_receipt/","title":"Transaction Receipt","text":""},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt","title":"eth_rpc.TransactionReceipt","text":"<p>               Bases: <code>Request</code>, <code>TransactionReceipt</code>, <code>Generic[Network]</code></p>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.transaction_hash","title":"transaction_hash  <code>instance-attribute</code>","text":"<pre><code>transaction_hash\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.block_hash","title":"block_hash  <code>instance-attribute</code>","text":"<pre><code>block_hash\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.block_number","title":"block_number  <code>instance-attribute</code>","text":"<pre><code>block_number\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.logs","title":"logs  <code>instance-attribute</code>","text":"<pre><code>logs\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.contract_address","title":"contract_address  <code>instance-attribute</code>","text":"<pre><code>contract_address\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.effective_gas_price","title":"effective_gas_price  <code>instance-attribute</code>","text":"<pre><code>effective_gas_price\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.cumulative_gas_used","title":"cumulative_gas_used  <code>instance-attribute</code>","text":"<pre><code>cumulative_gas_used\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.from_","title":"from_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>from_ = Field(alias='from')\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.gas_used","title":"gas_used  <code>instance-attribute</code>","text":"<pre><code>gas_used\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.logs_bloom","title":"logs_bloom  <code>instance-attribute</code>","text":"<pre><code>logs_bloom\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status = None\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.to","title":"to  <code>instance-attribute</code>","text":"<pre><code>to\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.transaction_index","title":"transaction_index  <code>instance-attribute</code>","text":"<pre><code>transaction_index\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.has_log","title":"has_log","text":"<pre><code>has_log(topic)\n</code></pre> <p>Checks is a transaction has a topic in it</p> Source code in <code>eth_rpc/models/transaction_receipt.py</code> <pre><code>def has_log(self, topic: HexStr):\n    \"\"\"Checks is a transaction has a topic in it\"\"\"\n    t = bytes.fromhex(topic.replace(\"0x\", \"\"))\n\n    return t in BloomFilter(self.logs_bloom)\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.get_by_hash","title":"get_by_hash  <code>classmethod</code>","text":"<pre><code>get_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, Optional[TransactionReceiptModel]]:\n    return RPCResponseModel(\n        self.rpc().get_tx_receipt,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.get_block_receipts","title":"get_block_receipts  <code>classmethod</code>","text":"<pre><code>get_block_receipts(block_number=None, block_hash=None)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_block_receipts(\n    self,\n    block_number: Optional[int] = None,\n    block_hash: Optional[HexStr] = None,\n) -&gt; RPCResponseModel[list[HexStr], list[TransactionReceiptModel]]:\n    if block_number:\n        param = hex(block_number)\n    elif block_hash:\n        param = block_hash\n    return RPCResponseModel(\n        self.rpc().get_block_receipts,\n        [HexStr(param)],\n    )\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.alchemy_get_block_receipts","title":"alchemy_get_block_receipts  <code>classmethod</code>","text":"<pre><code>alchemy_get_block_receipts(\n    block_number=None, block_hash=None\n)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef alchemy_get_block_receipts(\n    self,\n    block_number: Optional[int] = None,\n    block_hash: Optional[HexStr] = None,\n) -&gt; RPCResponseModel[AlchemyBlockReceipt, \"AlchemyReceiptsResponse\"]:\n    return RPCResponseModel(\n        self.rpc().alchemy_get_block_receipts,\n        AlchemyBlockReceipt(\n            params=AlchemyParams(\n                block_number=HexInteger(block_number) if block_number else None,\n                block_hash=block_hash,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/","title":"Wallet","text":""},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet","title":"eth_rpc.PrivateKeyWallet","text":"<p>               Bases: <code>BaseWallet</code></p>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.private_key","title":"private_key  <code>instance-attribute</code>","text":"<pre><code>private_key\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.address","title":"address  <code>property</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.get_nonce","title":"get_nonce","text":"<pre><code>get_nonce(block_number='latest')\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def get_nonce(self, block_number: int | BLOCK_STRINGS = \"latest\"):\n    return RPCResponseModel(\n        self.rpc().get_tx_count,\n        GetAccountArgs(\n            address=self.address,\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    self._account = Account.from_key(self.private_key)\n    return super().model_post_init(__context)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.get_pvt_key","title":"get_pvt_key  <code>staticmethod</code>","text":"<pre><code>get_pvt_key()\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@staticmethod\ndef get_pvt_key() -&gt; HexStr:\n    priv = secrets.token_hex(32)\n    return HexStr(f\"0x{priv}\")\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.create_new","title":"create_new  <code>classmethod</code>","text":"<pre><code>create_new()\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@classmethod\ndef create_new(cls):\n    return cls(private_key=cls.get_pvt_key())\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.sign_transaction","title":"sign_transaction","text":"<pre><code>sign_transaction(tx)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def sign_transaction(self, tx: PreparedTransaction) -&gt; SignedTransaction:\n    signed_tx = self._account.sign_transaction(tx.model_dump())\n    return SignedTransaction(\n        raw_transaction=signed_tx[0].hex(),\n        hash=signed_tx.hash.hex(),\n        r=signed_tx.r,\n        s=signed_tx.s,\n        v=signed_tx.v,\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.send_raw_transaction","title":"send_raw_transaction","text":"<pre><code>send_raw_transaction(tx)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def send_raw_transaction(\n    self, tx: HexStr\n) -&gt; RPCResponseModel[RawTransaction, HexStr]:\n    return RPCResponseModel(\n        self.rpc().send_raw_tx,\n        RawTransaction(\n            signed_tx=tx,\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.prepare_and_sign","title":"prepare_and_sign","text":"<pre><code>prepare_and_sign(\n    *,\n    to,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    data=HexStr(\"0x\"),\n    nonce=None\n)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def prepare_and_sign(\n    self,\n    *,\n    to: HexAddress,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    data: HexStr = HexStr(\"0x\"),\n    nonce: Optional[int] = None,\n):\n    prepared = self.prepare(\n        to=to,\n        value=value,\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        data=data,\n        nonce=nonce,\n    )\n    return self.sign_transaction(prepared)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.prepare","title":"prepare","text":"<pre><code>prepare(\n    *,\n    to,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    data=HexStr(\"0x\"),\n    nonce=None\n)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def prepare(\n    self,\n    *,\n    to: HexAddress,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    data: HexStr = HexStr(\"0x\"),\n    nonce: Optional[int] = None,\n):\n    # TODO: this assumes sync\n    gas = self.estimate_gas(to=to, data=data).sync\n    access_list = None\n    rpc = _force_get_global_rpc()\n    chain_id = rpc.chain_id.sync()\n\n    max_priority_fee_per_gas = max_priority_fee_per_gas or Block.priority_fee().sync\n    base_fee_per_gas = Block.pending().sync.base_fee_per_gas\n    assert base_fee_per_gas, \"block is earlier than London Hard Fork\"\n    max_fee_per_gas = max_fee_per_gas or (\n        2 * base_fee_per_gas + max_priority_fee_per_gas\n    )\n\n    return PreparedTransaction(\n        data=data,\n        to=to,\n        gas=HexInteger(gas),\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        nonce=nonce or self.get_nonce().sync,\n        value=value,\n        access_list=access_list,\n        chain_id=chain_id,\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.estimate_gas","title":"estimate_gas","text":"<pre><code>estimate_gas(to, block_number='latest', data=HexStr('0x'))\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def estimate_gas(\n    self,\n    to: HexAddress,\n    block_number: HexInteger | Literal[\"latest\", \"pending\"] = \"latest\",\n    data: HexStr = HexStr(\"0x\"),\n) -&gt; RPCResponseModel[CallWithBlockArgs, HexInteger]:\n    return RPCResponseModel(\n        self.rpc().estimate_gas,\n        CallWithBlockArgs(\n            params=EthCallParams(\n                from_=self.address,\n                to=to,\n                data=data,\n            ),\n            block_number=block_number,\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.transfer","title":"transfer","text":"<pre><code>transfer(to, value)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def transfer(self, to: HexAddress, value: int):\n    prepared_tx = self.prepare(to=to, value=value)\n    signed_tx = self.sign_transaction(prepared_tx)\n    return self.send_raw_transaction(HexStr(\"0x\" + signed_tx.raw_transaction)).sync\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.sign_hash","title":"sign_hash","text":"<pre><code>sign_hash(hashed)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def sign_hash(self, hashed: bytes) -&gt; SignedMessage:\n    return Account._sign_hash(hashed, self._account.key)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.rsv_to_signature","title":"rsv_to_signature  <code>staticmethod</code>","text":"<pre><code>rsv_to_signature(r, s, v)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@staticmethod\ndef rsv_to_signature(r: int, s: int, v: int) -&gt; HexStr:\n    rr = hex(r)[2:].zfill(64)\n    ss = hex(s)[2:].zfill(64)\n    vv = hex(v)[2:]\n    return HexStr(\"0x\" + rr + ss + vv)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.signature_to_rsv","title":"signature_to_rsv  <code>staticmethod</code>","text":"<pre><code>signature_to_rsv(signature)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@staticmethod\ndef signature_to_rsv(signature: HexStr) -&gt; tuple[int, int, int]:\n    v = signature[-2:]\n    s = signature[-66:-2]\n    r = signature[:-66].lstrip(\"0x\")\n\n    return int(r, 16), int(s, 16), int(v, 16)\n</code></pre>"},{"location":"getting-started/","title":"QUICK START","text":"<p>install using pip</p> <pre><code>pip install eth-rpc-py\npip install eth-typeshed-py\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>We recommend setting up an Alchemy account so you can utilize your API key for requests, otherwise you will use public RPCs that typically do not allow for websocket connections or frequent requests.  You can also set your RPC directly</p> <pre><code>import os\n\nfrom eth_rpc import set_alchemy_key, set_rpc_url\nfrom eth_rpc.networks import Ethereum\n\n# If you want to set an RPC for a network directly\nset_rpc_url(Ethereum, os.environ[\"MY_PRIVATE_RPC_URL\"])\n\n# Or you can set your alchemy key and it will automatically set it as the default RPC for all networks\nset_alchemy_key(os.environ[\"ALCHEMY_KEY\"])\n</code></pre>"},{"location":"getting-started/account/","title":"Account Class","text":"<p>The Account class is part of the eth_rpc package and provides methods for interacting with Ethereum accounts via RPC calls.</p> <pre><code>from eth_rpc import Account\n\neth_address = \"0x0000000000000000000000000000000000000000\"\n# get an account's balance\nbalance = await Account.get_balance(eth_address)\n\n# Get all account data\naccount_data = await Account.get_account(eth_address)\n\n# Access and display individual fields\nprint(f\"Account Details for {eth_address}:\")\nprint(f\"Balance: {account_data.balance} wei\")\nprint(f\"Nonce: {account_data.nonce}\")\nprint(f\"Code Hash: {account_data.code_hash}\")\nprint(f\"Storage Root: {account_data.storage_root}\")\n\n# Convert balance to Ether for better readability\nbalance_in_ether = int(account_data.balance, 16) / 1e18\nprint(f\"Balance in Ether: {balance_in_ether:.6f} ETH\")\n\n# Check if the account is a contract\nis_contract = account_data.code_hash != \"0x0000000\"\nprint(f\"Is Contract: {'Yes' if is_contract else 'No'}\")\n</code></pre> <p>Warning</p> <p><code>get_account</code> will not work on the Alchemy RPC; it does not support the <code>eth_getAccount</code> method.  It will work with quicknode and some other RPC providers.</p>"},{"location":"getting-started/blocks/","title":"Blocks","text":"<p>The Block class is your connection to the different RPC endpoints that are specific to Blocks onchain.  Typically you will want to check things like the current block number, or you might want to access all the transactions for a specific block.</p> <p>The returned <code>Block</code> is a Pydantic BaseModel, providing typed access to all associated fields.</p> <pre><code>from eth_rpc import Block\n\nblock = await Block.load_by_number(3_000_000)\n</code></pre> <p>If you want to load with transactions, just specify in the request:</p> <pre><code>from eth_rpc import Block, Transaction\n\nblock = await Block.load_by_number(3_000_000, with_tx_data=True)\ntransactions: list[Transaction] = block.transactions\n</code></pre> <p>Now we have access to a Transaction, which is also a Pydantic BaseModel, and it exposes the ability to access it's <code>TransactionReceipt</code>.  So similar to an ORM, all the different types are able to communicate with the RPC in a meaningful way.</p> <pre><code>tx = transactions[0]\nawait tx.receipt()\n</code></pre>"},{"location":"getting-started/blocks/methods/","title":"Blocks RPC Methods","text":""},{"location":"getting-started/blocks/methods/#fee-history","title":"Fee History","text":"<p>We can also load the FeeHistory for a series of blocks to help plan our transaction:</p> <pre><code>fee_history = await Block.fee_history(\n    block_count=4,\n    lower_percentile=25,\n    upper_percentile=75,\n    block_number=20_000_000,  # by default this is set to \"latest\"\n)\n# fee_history.base_fee_per_gas == [5104157871, 5171340881, 5004025121, 4936957716, 4776082506]\n</code></pre> <p>This shows the base_fee_per_gas for the last four blocks, so you can accurately estimate the minimum base_fee_per_gas needed for a transaction.</p>"},{"location":"getting-started/blocks/methods/#subscription","title":"Subscription","text":"<p>We can utilize the RPC websocket endpoint to connect and subscribe to blocks as they are ingested.  You can also backfill from a certain block number, which is useful when you have a persistent stream and want to be able to resume from a certain number.</p> <pre><code>async for block in Block.subscribe_from(20_000_000):\n    # print the number and their tx count\n    print(block.number, len(block.transactions))\n</code></pre>"},{"location":"getting-started/blocks/methods/#additional-methods","title":"Additional Methods","text":"<p>There are a few other methods supported by most RPCs that are blocks related:</p> <pre><code>from eth_typing import HexStr\n\nawait Block.get_block_transaction_count(20_000_000)\nawait Block.load_by_number(20_000_000, with_tx_data=False)\nawait Block.get_number()  # get current block number\nawait Block.latest()\nawait Block.pending()\nawait Block.load_by_hash(\n    HexStr(\n        \"0x13ced9eaa49a522d4e7dcf80a739a57dbf08f4ce5efc4edbac86a66d8010f693\"\n    )\n)\n</code></pre>"},{"location":"getting-started/blocks/model/","title":"The Blocks Model","text":"<p><code>Block</code> is a Pydantic BaseModel.  It has all the fields provided by the standard Ethereum RPC.</p> <pre><code>class Block(RPCModel):\n    number: HexInteger\n    hash: Optional[HexStr] = None\n    base_fee_per_gas: Optional[HexInteger] = None\n    transactions: list[\"Transaction\"] | list[HexStr] = Field(default_factory=list)\n    difficulty: HexInteger\n    extra_data: HexStr\n    gas_limit: HexInteger\n    gas_used: HexInteger\n    logs_bloom: HexStr\n    miner: Optional[HexAddress] = None\n    mix_hash: HexStr\n    nonce: Optional[HexStr] = None\n    parent_hash: HexStr\n    receipts_root: HexStr\n    sha3_uncles: HexStr\n    size: HexInteger\n    state_root: HexStr\n    timestamp: datetime\n    total_difficulty: Optional[HexInteger] = None\n    transactions_root: HexStr\n    uncles: list[HexStr] = Field(default_factory=list)\n</code></pre> <p>Tip</p> <p>The block will either have a list of Transaction hashes or a list of Transactions, depending on whether or not you request the block <code>with_tx_data=True</code>.  By default it returns the transaction hashes.</p>"},{"location":"getting-started/contracts/","title":"Contracts","text":""},{"location":"getting-started/contracts/#contract-class","title":"Contract Class","text":"<p>The Contract class is a fundamental component in our system, representing a smart contract on the blockchain. It provides a typed, structured way to interact with and manage onchain contract interactions.</p>"},{"location":"getting-started/contracts/#overview","title":"Overview","text":"<p>A <code>Contract</code> instance encapsulates the following key elements:</p> <ul> <li>Contract address</li> <li>Contract Interface</li> </ul>"},{"location":"getting-started/contracts/#key-features","title":"Key Features","text":"<ol> <li>Method Invocation: Call contract methods easily.</li> <li>Event Listening: Subscribe to and handle contract events.</li> <li>State Reading: Read the current state of the contract.</li> <li>Transaction Sending: Send transactions to modify the contract state.</li> </ol>"},{"location":"getting-started/contracts/#basic-usage","title":"Basic Usage","text":"<p>The real focus is on making it easier to interact with deployed smart contracts and having some greater type safety.  For example, say you want to interact with a contract you just deployed, ie:</p> <pre><code>contract MyContract {\n    function foo(address[] users) external returns(bool success) {}\n}\n</code></pre> <p>Rather than copying the abi into a JSON file, you can create a typed contract interface:</p> <pre><code>from typing import Annotated\n\nfrom eth_rpc.contract import ProtocolBase, ContractFunc\nfrom eth_rpc import Transaction\nfrom eth_rpc.wallet import PrivateKeyWallet\nfrom eth_rpc.types import HexStr, Name, primitives\n\n\nclass MyContract(ProtocolBase):\n    foo: ContractFunc[\n        list[primitives.address],  # input type is a list of addresses\n        Annotated[bool, Name(\"success\")],  # response type is a boolean\n    ] = METHOD # this is necessary for the type checker to recognize it as a contract method\n\ncontract = MyContract(address=\"&lt;Contract Address&gt;\")\n# create a wallet for yourself\nwallet = PrivateKeyWallet(private_key=os.environ[\"PK\"])\n\n# call it without execution:\nresponse: bool = await contract.foo(['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', ...]).call(\n    from_=wallet.address,\n)\n\n# or call it with execution:\ntx_hash: HexStr = await contract.foo(['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', ...]).execute(wallet)\ntx: Transaction[Ethereum] = await Transaction[Ethereum].get_by_hash(tx_hash)\n</code></pre>"},{"location":"getting-started/transactions/","title":"Transactions","text":"<p>The Transaction class abstracts all requests related to Ethereum Transactions.  With the transactions model you can access Transactions and TransactionReceipts.</p> <pre><code>from eth_typing import HexStr\n\nfrom eth_rpc import Transaction, TransactionReceipt\n\n\ntx_hash: HexStr = HexStr(\n    \"0x5c504ed432cb51138bcf09aa5e8a410dd4a1e204ef84bfed1be16dfba1b22060\"\n)\n\ntx: Transaction = await Transaction.get_by_hash(tx_hash)\n# get the receipt\ntx_reciept: TransactionReceipt = await Transaction.get_receipt_by_hash(tx.hash)\n\n# you can also access the receipt directly from the tx object\ntx_receipt: TransactionReceipt = await tx.receipt()\n\n# you can get a transaction from a block by its index\ntx: Transaction = await Transaction.get_by_index(\n    transaction_index=0,\n    block_hash=HexStr(\n        \"0x4e3a3754410177e6937ef1f84bba68ea139e8d1a2258c5f85db9f1cd715a1bdd\",\n    ),\n)\n</code></pre>"},{"location":"getting-started/transactions/#pending-transactions","title":"Pending Transactions","text":"<p>You can also load pending transactions by hash, from a mempool monitor</p> <pre><code># subscribe to all pending transactions, and print the hash\nasync for tx in Transaction.subscribe_pending():\n    print(tx.hash)\n</code></pre>"},{"location":"getting-started/transactions/#getting-a-transactions-block","title":"Getting a transactions block","text":"<p>You can access the transactions block by calling the <code>get_block</code> method on a transaction object.  As usual, <code>with_tx_data</code> is an optional argument.</p> <pre><code>tx: Transaction = await Transaction.get_by_hash(tx_hash)\nblock: Block = await tx.get_block(with_tx_data=True)\n</code></pre>"},{"location":"getting-started/transactions/model/","title":"Transaction Model","text":"<p><code>Transaction</code> and <code>TransactionReceipt</code> are both Pydantic BaseModels.  It has all the fields provided by the standard Ethereum RPC.</p> <pre><code>class Transaction(BaseModel):\n    hash: HexStr\n    access_list: Optional[list[AccessList]] = None\n    chain_id: Optional[HexInteger] = None\n    from_: HexStr = Field(alias=\"from\")\n    gas: HexInteger\n    gas_price: HexInteger\n    max_fee_per_gas: Optional[HexInteger] = None\n    max_priority_fee_per_gas: Optional[HexInteger] = None\n    input: HexStr\n    nonce: HexInteger\n    r: HexStr\n    s: HexStr\n    v: HexInteger\n    to: Optional[HexStr]\n    type: Optional[HexInteger] = None\n    value: HexInteger\n    y_parity: HexInteger | None = None\n    block_hash: HexStr\n    block_number: HexInteger\n    transaction_index: HexInteger\n\n\nclass TransactionReceipt(BaseModel):\n    transaction_hash: HexStr\n    block_hash: HexStr\n    block_number: HexInteger\n    logs: list[Log]\n    contract_address: Optional[HexStr]\n    effective_gas_price: HexInteger\n    cumulative_gas_used: HexInteger\n    from_: HexAddress = Field(alias=\"from\")\n    gas_used: HexInteger\n    logs_bloom: HexInteger\n    status: Optional[HexInteger] = None\n    to: Optional[HexAddress]\n    transaction_index: HexInteger\n    type: HexInteger\n</code></pre>"}]}