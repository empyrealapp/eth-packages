{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"getting-started/","title":"QUICK START","text":"<p>install using pip</p> <pre><code>pip install eth-rpc-py\npip install eth-typeshed-py\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>We recommend setting up an Alchemy account so you can utilize your API key for requests, otherwise you will use public RPCs that typically do not allow for websocket connections or frequent requests.  You can also set your RPC directly</p> <pre><code>import os\n\nfrom eth_rpc import set_alchemy_key, set_rpc_url\nfrom eth_rpc.networks import Ethereum\n\n# If you want to set an RPC for a network directly\nset_rpc_url(Ethereum, os.environ[\"MY_PRIVATE_RPC_URL\"])\n\n# Or you can set your alchemy key and it will automatically set it as the default RPC for all networks\nset_alchemy_key(os.environ[\"ALCHEMY_KEY\"])\n</code></pre>"},{"location":"getting-started/blocks/","title":"Blocks","text":"<p>The <code>Blocks</code> class is your connection to the different RPC endpoints that are specific to Blocks onchain.  Typically you will want to check things like the current block number, or you might want to access all the transactions for a specific block.</p> <p>The returned <code>Block</code> is a Pydantic BaseModel, providing typed access to all associated fields.</p> <pre><code>from eth_rpc import Block\n\nblock = await Block.load_by_number(3_000_000)\n</code></pre> <p>If you want to load with transactions, just specify in the request:</p> <pre><code>from eth_rpc import Block, Transaction\n\nblock = await Block.load_by_number(3_000_000, with_tx_data=True)\ntransactions: list[Transaction] = block.transactions\n</code></pre> <p>Now we have access to a Transaction, which is also a Pydantic BaseModel, and it exposes the ability to access it's <code>TransactionReceipt</code>.  So similar to an ORM, all the different types are able to communicate with the RPC in a meaningful way.</p> <pre><code>tx = transactions[0]\nawait tx.receipt()\n</code></pre>"},{"location":"getting-started/blocks/methods/","title":"Blocks RPC Methods","text":""},{"location":"getting-started/blocks/methods/#fee-history","title":"Fee History","text":"<p>We can also load the FeeHistory for a series of blocks to help plan our transaction:</p> <pre><code>fee_history = await Block.fee_history(\n    block_count=4,\n    lower_percentile=25,\n    upper_percentile=75,\n    block_number=20_000_000,  # by default this is set to \"latest\"\n)\n# fee_history.base_fee_per_gas == [5104157871, 5171340881, 5004025121, 4936957716, 4776082506]\n</code></pre> <p>This shows the base_fee_per_gas for the last four blocks, so you can accurately estimate the minimum base_fee_per_gas needed for a transaction.</p>"},{"location":"getting-started/blocks/methods/#subscription","title":"Subscription","text":"<p>We can utilize the RPC websocket endpoint to connect and subscribe to blocks as they are ingested.  You can also backfill from a certain block number, which is useful when you have a persistent stream and want to be able to resume from a certain number.</p> <pre><code>async for block in Block.subscribe_from(20_000_000):\n    # print the number and their tx count\n    print(block.number, len(block.transactions))\n</code></pre>"},{"location":"getting-started/blocks/methods/#additional-methods","title":"Additional Methods","text":"<p>There are a few other methods supported by most RPCs that are blocks related:</p> <pre><code>from eth_typing import HexStr\n\nawait Block.get_block_transaction_count(20_000_000)\nawait Block.load_by_number(20_000_000, with_tx_data=False)\nawait Block.get_number()  # get current block number\nawait Block.latest()\nawait Block.pending()\nawait Block.load_by_hash(\n    HexStr(\n        \"0x13ced9eaa49a522d4e7dcf80a739a57dbf08f4ce5efc4edbac86a66d8010f693\"\n    )\n)\n</code></pre>"},{"location":"getting-started/blocks/model/","title":"The Blocks Model","text":"<p><code>Block</code> is a Pydantic BaseModel.  It has all the fields provided by the standard Ethereum RPC.</p> <pre><code>class Block(RPCModel):\n    number: HexInteger\n    hash: Optional[HexStr] = None\n    base_fee_per_gas: Optional[HexInteger] = None\n    transactions: list[\"Transaction\"] | list[HexStr] = Field(default_factory=list)\n    difficulty: HexInteger\n    extra_data: HexStr\n    gas_limit: HexInteger\n    gas_used: HexInteger\n    logs_bloom: HexStr\n    miner: Optional[HexAddress] = None\n    mix_hash: HexStr\n    nonce: Optional[HexStr] = None\n    parent_hash: HexStr\n    receipts_root: HexStr\n    sha3_uncles: HexStr\n    size: HexInteger\n    state_root: HexStr\n    timestamp: datetime\n    total_difficulty: Optional[HexInteger] = None\n    transactions_root: HexStr\n    uncles: list[HexStr] = Field(default_factory=list)\n</code></pre> <p>Tip</p> <p>The block will either have a list of Transaction hashes or a list of Transactions, depending on whether or not you request the block <code>with_tx_data=True</code>.  By default it returns the transaction hashes.</p>"},{"location":"getting-started/transactions/","title":"Transactions","text":"<p>The Transactions model abstracts all requests related to Ethereum Transactions.  With the transactions model you can access Transactions and TransactionReceipts.</p> <pre><code>from eth_typing import HexStr\n\nfrom eth_rpc import Transaction, TransactionReceipt\n\n\ntx_hash: HexStr = HexStr(\n    \"0x5c504ed432cb51138bcf09aa5e8a410dd4a1e204ef84bfed1be16dfba1b22060\"\n)\n\ntx: Transaction = await Transaction.get_by_hash(tx_hash)\n# get the receipt\ntx_reciept: TransactionReceipt = await Transaction.get_receipt_by_hash(tx.hash)\n\n# you can also access the receipt directly from the tx object\ntx_receipt: TransactionReceipt = await tx.receipt()\n\n# you can get a transaction from a block by its index\ntx: Transaction = await Transaction.get_by_index(\n    transaction_index=0,\n    block_hash=HexStr(\n        \"0x4e3a3754410177e6937ef1f84bba68ea139e8d1a2258c5f85db9f1cd715a1bdd\",\n    ),\n)\n</code></pre>"},{"location":"getting-started/transactions/#pending-transactions","title":"Pending Transactions","text":"<p>You can also load pending transactions by hash, from a mempool monitor</p> <pre><code># subscribe to all pending transactions, and print the hash\nasync for tx in Transaction.subscribe_pending():\n    print(tx.hash)\n</code></pre>"},{"location":"getting-started/transactions/#getting-a-transactions-block","title":"Getting a transactions block","text":"<p>You can access the transactions block by calling the <code>get_block</code> method on a transaction object.  As usual, <code>with_tx_data</code> is an optional argument.</p> <pre><code>tx: Transaction = await Transaction.get_by_hash(tx_hash)\nblock: Block = await tx.get_block(with_tx_data=True)\n</code></pre>"},{"location":"getting-started/transactions/model/","title":"Transaction Model","text":"<p><code>Transaction</code> and <code>TransactionReceipt</code> are both Pydantic BaseModels.  It has all the fields provided by the standard Ethereum RPC.</p> <pre><code>class Transaction(BaseModel):\n    hash: HexStr\n    access_list: Optional[list[AccessList]] = None\n    chain_id: Optional[HexInteger] = None\n    from_: HexStr = Field(alias=\"from\")\n    gas: HexInteger\n    gas_price: HexInteger\n    max_fee_per_gas: Optional[HexInteger] = None\n    max_priority_fee_per_gas: Optional[HexInteger] = None\n    input: HexStr\n    nonce: HexInteger\n    r: HexStr\n    s: HexStr\n    v: HexInteger\n    to: Optional[HexStr]\n    type: Optional[HexInteger] = None\n    value: HexInteger\n    y_parity: HexInteger | None = None\n    block_hash: HexStr\n    block_number: HexInteger\n    transaction_index: HexInteger\n\n\nclass TransactionReceipt(BaseModel):\n    transaction_hash: HexStr\n    block_hash: HexStr\n    block_number: HexInteger\n    logs: list[Log]\n    contract_address: Optional[HexStr]\n    effective_gas_price: HexInteger\n    cumulative_gas_used: HexInteger\n    from_: HexAddress = Field(alias=\"from\")\n    gas_used: HexInteger\n    logs_bloom: HexInteger\n    status: Optional[HexInteger] = None\n    to: Optional[HexAddress]\n    transaction_index: HexInteger\n    type: HexInteger\n</code></pre>"}]}