{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"api/access_list/","title":"Access List","text":""},{"location":"api/access_list/#eth_rpc.models.AccessList","title":"eth_rpc.models.AccessList","text":"<p>               Bases: <code>RPCModel</code></p>"},{"location":"api/access_list/#eth_rpc.models.AccessList.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/access_list/#eth_rpc.models.AccessList.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/access_list/#eth_rpc.models.AccessList.storage_keys","title":"storage_keys  <code>instance-attribute</code>","text":"<pre><code>storage_keys\n</code></pre>"},{"location":"api/access_list/#eth_rpc.models.AccessList.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/account/","title":"Account","text":""},{"location":"api/account/#eth_rpc.Account","title":"eth_rpc.Account","text":"<p>               Bases: <code>Request</code>, <code>Account</code>, <code>Generic[Network]</code></p>"},{"location":"api/account/#eth_rpc.Account.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.code_hash","title":"code_hash  <code>instance-attribute</code>","text":"<pre><code>code_hash\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.storage_root","title":"storage_root  <code>instance-attribute</code>","text":"<pre><code>storage_root\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.balance","title":"balance  <code>instance-attribute</code>","text":"<pre><code>balance\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.nonce","title":"nonce  <code>instance-attribute</code>","text":"<pre><code>nonce\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.get_balance","title":"get_balance","text":"<pre><code>get_balance(address, block_number='latest')\n</code></pre> Source code in <code>eth_rpc/account.py</code> <pre><code>def get_balance(\n    self, address: HexAddress, block_number: int | BLOCK_STRINGS = \"latest\"\n) -&gt; RPCResponseModel[GetAccountArgs, HexInteger]:\n    return RPCResponseModel(\n        self.rpc().get_balance,\n        GetAccountArgs(\n            address=address,\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api/account/#eth_rpc.Account.get_account","title":"get_account","text":"<pre><code>get_account(address, block_number='latest')\n</code></pre> Source code in <code>eth_rpc/account.py</code> <pre><code>def get_account(\n    self, address: HexAddress, block_number: int | BLOCK_STRINGS = \"latest\"\n) -&gt; RPCResponseModel[GetAccountArgs, AccountModel]:\n    return RPCResponseModel(\n        self.rpc().get_account,\n        GetAccountArgs(\n            address=address,\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api/block/","title":"Block","text":""},{"location":"api/block/#eth_rpc.Block","title":"eth_rpc.Block","text":"<p>               Bases: <code>Block</code>, <code>Request</code>, <code>Generic[Network]</code></p>"},{"location":"api/block/#eth_rpc.Block.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.hash","title":"hash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hash = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.transactions","title":"transactions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transactions = Field(default_factory=list)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.base_fee_per_gas","title":"base_fee_per_gas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>base_fee_per_gas = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.difficulty","title":"difficulty  <code>instance-attribute</code>","text":"<pre><code>difficulty\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.extra_data","title":"extra_data  <code>instance-attribute</code>","text":"<pre><code>extra_data\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.gas_limit","title":"gas_limit  <code>instance-attribute</code>","text":"<pre><code>gas_limit\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.gas_used","title":"gas_used  <code>instance-attribute</code>","text":"<pre><code>gas_used\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.logs_bloom","title":"logs_bloom  <code>instance-attribute</code>","text":"<pre><code>logs_bloom\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.miner","title":"miner  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>miner = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.mix_hash","title":"mix_hash  <code>instance-attribute</code>","text":"<pre><code>mix_hash\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.nonce","title":"nonce  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nonce = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.parent_hash","title":"parent_hash  <code>instance-attribute</code>","text":"<pre><code>parent_hash\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.receipts_root","title":"receipts_root  <code>instance-attribute</code>","text":"<pre><code>receipts_root\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.sha3_uncles","title":"sha3_uncles  <code>instance-attribute</code>","text":"<pre><code>sha3_uncles\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.state_root","title":"state_root  <code>instance-attribute</code>","text":"<pre><code>state_root\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.total_difficulty","title":"total_difficulty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_difficulty = None\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.transactions_root","title":"transactions_root  <code>instance-attribute</code>","text":"<pre><code>transactions_root\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.uncles","title":"uncles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uncles = Field(default_factory=list)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.normalize_timestamp","title":"normalize_timestamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normalize_timestamp = field_validator(\n    \"timestamp\", mode=\"before\"\n)(load_datetime_string)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.has_log","title":"has_log","text":"<pre><code>has_log(topic)\n</code></pre> Source code in <code>eth_rpc/models/block.py</code> <pre><code>def has_log(self, topic: HexStr):\n    t = bytes.fromhex(topic.replace(\"0x\", \"\"))\n    return t in BloomFilter(self.logs_bloom)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.compress","title":"compress","text":"<pre><code>compress()\n</code></pre> Source code in <code>eth_rpc/models/block.py</code> <pre><code>def compress(self) -&gt; bytes:\n    return zlib.compress(self.model_dump_json().encode(\"utf-8\"))\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.priority_fee","title":"priority_fee  <code>classmethod</code>","text":"<pre><code>priority_fee()\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef priority_fee(cls) -&gt; RPCResponseModel[NoArgs, HexInteger]:\n    return RPCResponseModel(\n        cls.rpc().max_priority_fee_per_gas,\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.fee_history","title":"fee_history  <code>classmethod</code>","text":"<pre><code>fee_history(\n    block_count=4,\n    lower_percentile=25,\n    upper_percentile=75,\n    block_number=\"latest\",\n)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef fee_history(\n    cls,\n    block_count: int = 4,\n    lower_percentile: int = 25,\n    upper_percentile: int = 75,\n    block_number: BlockReference = \"latest\",\n) -&gt; RPCResponseModel[FeeHistoryArgs, FeeHistory]:\n    return RPCResponseModel(\n        cls.rpc().fee_history,\n        FeeHistoryArgs(\n            block_count=block_count,\n            block_number=block_number,\n            percentiles=[\n                lower_percentile,\n                upper_percentile,\n            ],\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.get_block_transaction_count","title":"get_block_transaction_count  <code>classmethod</code>","text":"<pre><code>get_block_transaction_count(block_number)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef get_block_transaction_count(\n    cls, block_number: HexInteger\n) -&gt; RPCResponseModel[BlockNumberArg, int]:\n    return RPCResponseModel(\n        cls.rpc().get_block_tx_count_by_number,\n        BlockNumberArg(\n            block_number=block_number,\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.load_by_number","title":"load_by_number  <code>classmethod</code>","text":"<pre><code>load_by_number(block_number, with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef load_by_number(\n    cls,\n    block_number: int | HexInteger | BLOCK_STRINGS,\n    with_tx_data: bool = False,\n) -&gt; RPCResponseModel[GetBlockByNumberArgs, \"Block[Network]\"]:\n    return RPCResponseModel(\n        cls.rpc().get_block_by_number,\n        GetBlockByNumberArgs(\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n            with_tx_data=with_tx_data,\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.get_number","title":"get_number  <code>classmethod</code>","text":"<pre><code>get_number()\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef get_number(cls) -&gt; RPCResponseModel[NoArgs, HexInteger]:\n    return RPCResponseModel(\n        cls.rpc().block_number,\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.load_by_datetime","title":"load_by_datetime  <code>async</code> <code>classmethod</code>","text":"<pre><code>load_by_datetime(\n    when, low=None, high=None, apprx_block_time=12\n)\n</code></pre> <p>Searches for a block, finding the first block before a datetime. Recursively searches, using low and high as the boundaries for the binary search.</p> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def load_by_datetime(\n    cls,\n    when: datetime,\n    low: int | None = None,\n    high: int | None = None,\n    apprx_block_time=12,\n) -&gt; \"Block[Network]\":\n    \"\"\"\n    Searches for a block, finding the first block before a datetime.\n    Recursively searches, using low and high as the boundaries for the binary search.\n    \"\"\"\n    Network = cls._network\n    if not when.tzinfo:\n        when = when.replace(tzinfo=timezone.utc)\n    if not (low and high):\n        now = datetime.now(timezone.utc)\n        diff = now - when\n        day_diff = diff.days\n        seconds_diff = day_diff * 24 * 3600\n        block_number = await cls[Network].get_number()  # type: ignore\n        if not low:\n            low = int(\n                max(block_number - (seconds_diff / (apprx_block_time * 0.8)), 0)\n            )\n        if not high:\n            high = int(\n                min(\n                    block_number - (seconds_diff / (apprx_block_time * 1.2)),\n                    block_number,\n                )\n            )\n    if when &lt; datetime(\n        year=2015,\n        month=7,\n        day=30,\n        hour=3,\n        minute=26,\n        second=13,\n        tzinfo=timezone.utc,\n    ):\n        raise ValueError(\"Block before genesis\")\n\n    if high &gt; low:\n        mid = (high + low) // 2\n        mid_block = await cls[Network].load_by_number(mid)  # type: ignore\n\n        if mid_block.timestamp == when:\n            return mid_block\n        elif mid_block.timestamp &gt; when:\n            return await cls[Network].load_by_datetime(when, low, mid - 1)  # type: ignore\n        else:\n            return await cls[Network].load_by_datetime(when, mid + 1, high)  # type: ignore\n    return await cls[Network].load_by_number(high)  # type: ignore\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.latest","title":"latest  <code>classmethod</code>","text":"<pre><code>latest(with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef latest(\n    cls, with_tx_data: bool = False\n) -&gt; RPCResponseModel[GetBlockByNumberArgs, \"Block[Network]\"]:\n    return cls.load_by_number(\"latest\", with_tx_data=with_tx_data)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.pending","title":"pending  <code>classmethod</code>","text":"<pre><code>pending(with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef pending(\n    cls, with_tx_data: bool = False\n) -&gt; RPCResponseModel[GetBlockByNumberArgs, \"Block[Network]\"]:\n    return cls.load_by_number(\"pending\", with_tx_data=with_tx_data)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.load_by_hash","title":"load_by_hash  <code>classmethod</code>","text":"<pre><code>load_by_hash(block_hash, with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef load_by_hash(\n    cls, block_hash: HexStr, with_tx_data: bool = False\n) -&gt; RPCResponseModel[GetBlockByHashArgs, \"Block[Network]\"]:\n    return RPCResponseModel(\n        cls.rpc().get_block_by_hash,\n        GetBlockByHashArgs(\n            block_hash=block_hash,\n            with_tx_data=with_tx_data,\n        ),\n    )\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.subscribe_from","title":"subscribe_from  <code>async</code> <code>classmethod</code>","text":"<pre><code>subscribe_from(start_block=None, with_tx_data=True)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def subscribe_from(\n    cls,\n    start_block: int | None = None,\n    with_tx_data: bool = True,\n) -&gt; AsyncIterator[\"Block[Network]\"]:\n    queue = asyncio.Queue[Block[Network]]()\n    should_publish_blocks = asyncio.Event()\n    asyncio.create_task(\n        cls.listen(\n            queue=queue,\n            publish_blocks=should_publish_blocks,\n            with_tx_data=with_tx_data,\n        )\n    )\n    latest = await cls.latest()\n    if not start_block:\n        start_block = latest.number\n    assert start_block\n\n    # NOTE: you pull latest twice because there can be a backfill while you're populating\n    for num in range(start_block, latest.number + 1):\n        yield await cls.load_by_number(num, with_tx_data=with_tx_data)\n\n    should_publish_blocks.set()\n    while True:\n        block = await queue.get()\n        if block.number &gt; latest.number:\n            yield block\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.listen","title":"listen  <code>async</code> <code>classmethod</code>","text":"<pre><code>listen(\n    *,\n    queue,\n    publish_blocks=DEFAULT_EVENT,\n    with_tx_data=True,\n    subscription_type=\"newHeads\"\n)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def listen(\n    cls,\n    *,\n    # TODO: typehinting this is tricky because the type of the Queue is conditional based on the subscription type\n    queue: asyncio.Queue,\n    publish_blocks: asyncio.Event = DEFAULT_EVENT,\n    with_tx_data: bool = True,\n    subscription_type: SUBSCRIPTION_TYPE = \"newHeads\",\n):\n    internal_queue: asyncio.Queue = asyncio.Queue()\n    flush_queue: bool = True\n    async for block in cls._listen(\n        with_tx_data=with_tx_data, subscription_type=subscription_type\n    ):\n        if publish_blocks.is_set():\n            if flush_queue:\n                while not internal_queue.empty():\n                    staged_block = await internal_queue.get()\n                    await queue.put(staged_block)\n                flush_queue = False\n            await queue.put(block)\n        else:\n            await internal_queue.put(block)\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.convert","title":"convert  <code>async</code> <code>classmethod</code>","text":"<pre><code>convert(block_value)\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\nasync def convert(cls, block_value: BLOCK_STRINGS | int) -&gt; int:\n    if isinstance(block_value, int):\n        return block_value\n    block = await cls.load_by_number(block_value)\n    return block.number\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.decompress","title":"decompress  <code>classmethod</code>","text":"<pre><code>decompress(raw_bytes)\n</code></pre> <p>Convert gzip compressed block to a Block</p> Source code in <code>eth_rpc/block.py</code> <pre><code>@classmethod\ndef decompress(cls, raw_bytes: bytes) -&gt; \"Block\":\n    \"\"\"Convert gzip compressed block to a Block\"\"\"\n    return Block.model_validate_json(zlib.decompress(raw_bytes))\n</code></pre>"},{"location":"api/block/#eth_rpc.Block.parent_block","title":"parent_block","text":"<pre><code>parent_block()\n</code></pre> Source code in <code>eth_rpc/block.py</code> <pre><code>def parent_block(self) -&gt; RPCResponseModel[GetBlockByHashArgs, \"Block[Network]\"]:\n    return self.load_by_hash(self.parent_hash)\n</code></pre>"},{"location":"api/contract/","title":"Contract","text":""},{"location":"api/contract/#eth_rpc.Contract","title":"eth_rpc.Contract","text":"<p>               Bases: <code>ContractT</code>, <code>Request</code></p>"},{"location":"api/contract/#eth_rpc.Contract.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract/#eth_rpc.Contract.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/contract_func/","title":"ContractFunc","text":""},{"location":"api/contract_func/#eth_rpc.ContractFunc","title":"eth_rpc.ContractFunc  <code>dataclass</code>","text":"<pre><code>ContractFunc(\n    func, contract, data=HexStr(\"0x\"), _network=None\n)\n</code></pre> <p>               Bases: <code>Generic[T, U]</code></p>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.contract","title":"contract  <code>instance-attribute</code>","text":"<pre><code>contract\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data = HexStr('0x')\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.address","title":"address  <code>property</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.alias","title":"alias  <code>property</code>","text":"<pre><code>alias\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.encode","title":"encode","text":"<pre><code>encode()\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def encode(self):\n    return bytes.fromhex(self.data[2:])\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.decode","title":"decode","text":"<pre><code>decode(result)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def decode(self, result: bytes) -&gt; U:\n    return self.func.decode_result(HexStr(result.hex()))\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.estimate_gas","title":"estimate_gas","text":"<pre><code>estimate_gas(\n    *, from_=None, block_number=\"latest\", sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def estimate_gas(\n    self,\n    *,\n    from_: Optional[HexAddress] = None,\n    block_number: HexInteger | Literal[\"latest\", \"pending\"] = \"latest\",\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexInteger]:\n    return run(\n        self._estimate_gas, from_=from_, block_number=block_number, sync=sync\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.access_list","title":"access_list","text":"<pre><code>access_list(\n    *,\n    gas=10000000,\n    sender=ADDRESS_ZERO,\n    block_number=None,\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def access_list(\n    self,\n    *,\n    gas: int = 10000000,\n    sender: HexAddress = ADDRESS_ZERO,\n    block_number: int | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[AccessListResponse]:\n    return run(\n        self._access_list,\n        gas=gas,\n        sender=sender,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.call","title":"call","text":"<pre><code>call(\n    *,\n    from_=None,\n    block_number=\"latest\",\n    value=0,\n    state_diff={},\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def call(\n    self,\n    *,\n    from_: Optional[HexAddress] = None,\n    block_number: int | BLOCK_STRINGS = \"latest\",\n    value: HexInteger | int = 0,\n    state_diff: dict[HexAddress, Any] = {},\n    sync: bool = False,\n) -&gt; MaybeAwaitable[EthResponse[T, U]]:\n    return run(self._call, from_, block_number, value, state_diff, sync=sync)\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.get","title":"get","text":"<pre><code>get(\n    *,\n    from_=None,\n    block_number=\"latest\",\n    value=0,\n    state_diff={},\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def get(\n    self,\n    *,\n    from_: Optional[HexAddress] = None,\n    block_number: int | BLOCK_STRINGS = \"latest\",\n    value: HexInteger | int = 0,\n    state_diff: dict[HexAddress, Any] = {},\n    sync: bool = False,\n) -&gt; MaybeAwaitable[U]:\n    return run(\n        self._get,\n        from_=from_,\n        block_number=block_number,\n        value=value,\n        state_diff=state_diff,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.prepare","title":"prepare","text":"<pre><code>prepare(\n    wallet,\n    *,\n    nonce=None,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    use_access_list=False,\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def prepare(\n    self,\n    wallet: \"BaseWallet\",\n    *,\n    nonce: Optional[int] = None,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    use_access_list: bool = False,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[PreparedTransaction]:\n    return run(\n        self._prepare,\n        wallet,\n        nonce=nonce,\n        value=value,\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        use_access_list=use_access_list,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/contract_func/#eth_rpc.ContractFunc.execute","title":"execute","text":"<pre><code>execute(\n    wallet,\n    *,\n    nonce=None,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    use_access_list=False,\n    sync=False\n)\n</code></pre> Source code in <code>eth_rpc/contract/function.py</code> <pre><code>def execute(\n    self,\n    wallet: \"BaseWallet\",\n    *,\n    nonce: Optional[int] = None,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    use_access_list: bool = False,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._execute,\n        wallet,\n        nonce=nonce,\n        value=value,\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        use_access_list=use_access_list,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/event/","title":"Event","text":""},{"location":"api/event/#eth_rpc.Event","title":"eth_rpc.Event","text":"<p>               Bases: <code>Request</code>, <code>Generic[T]</code></p>"},{"location":"api/event/#eth_rpc.Event.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.anonymous","title":"anonymous  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>anonymous = False\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.topic1_filter","title":"topic1_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic1_filter = IGNORE_VAL\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.topic2_filter","title":"topic2_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic2_filter = IGNORE_VAL\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.topic3_filter","title":"topic3_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic3_filter = IGNORE_VAL\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.addresses_filter","title":"addresses_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>addresses_filter = []\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_topic0","title":"get_topic0  <code>cached</code> <code>property</code>","text":"<pre><code>get_topic0\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.subscribe","title":"subscribe  <code>property</code>","text":"<pre><code>subscribe\n</code></pre> <p>This returns a callable for the async subscriber, allowing you to select the network for the subscription, ie.</p> <pre><code>my_event = Event[EventType](name=\"MyEvent\")\nasync for event in my_event.subscribe[Ethereum]():\n    ...\n</code></pre> <p>If no network is provided, it will use the default network.</p>"},{"location":"api/event/#eth_rpc.Event.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def model_post_init(self, __context) -&gt; None:\n    EventType, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    self._output_type = EventType\n    return super().model_post_init(__context)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.match_topics","title":"match_topics","text":"<pre><code>match_topics(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def match_topics(self, log: Log) -&gt; bool:\n    # TODO: addresses_filter\n    if len(log.topics) == 0:\n        return False\n    if log.topics[0] != self.get_topic0:\n        return False\n    if self.topic1_filter != IGNORE_VAL and len(log.topics) &gt;= 2:\n        if not self._matches(log.topics[1], self.topic1_filter):\n            return False\n    if self.topic2_filter != IGNORE_VAL and len(log.topics) &gt;= 3:\n        if not self._matches(log.topics[2], self.topic2_filter):\n            return False\n    if self.topic3_filter != IGNORE_VAL and len(log.topics) &gt;= 4:\n        if not self._matches(log.topics[3], self.topic3_filter):\n            return False\n    return True\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.match_address","title":"match_address","text":"<pre><code>match_address(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def match_address(self, log: Log) -&gt; bool:\n    if self.addresses_filter:\n        return log.address in self.addresses_filter\n    return True\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.match","title":"match","text":"<pre><code>match(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def match(self, log: Log) -&gt; bool:\n    return self.match_address(log) and self.match_topics(log)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.add_address","title":"add_address","text":"<pre><code>add_address(address)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def add_address(self, address: HexAddress | list[HexAddress]):\n    if isinstance(address, list):\n        for addr in address:\n            self.add_address(addr)\n    else:\n        if address not in self.addresses_filter:\n            self.addresses_filter.append(address)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.remove_address","title":"remove_address","text":"<pre><code>remove_address(address)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def remove_address(self, address: HexAddress):\n    self.addresses_filter = [\n        _address for _address in self.addresses_filter if _address != address\n    ]\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.process_value","title":"process_value  <code>staticmethod</code>","text":"<pre><code>process_value(type_name, v)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>@staticmethod\ndef process_value(type_name, v: str):\n    # strip prefix if necessary\n    if \"0x\" in v:\n        v = v[2:]\n\n    if type_name == \"address\":\n        # last 20 bytes of value\n        return \"0x{}\".format(v[-40:])\n    if \"bytes\" in type_name:\n        return bytes.fromhex(v)\n    if \"uint\" in type_name:\n        return int.from_bytes(bytes.fromhex(v), \"big\", signed=False)\n    elif \"int\" in type_name:\n        return int.from_bytes(bytes.fromhex(v), \"big\", signed=True)\n    if type_name == \"bool\":\n        return v[-1] == \"1\"\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.from_dict","title":"from_dict","text":"<pre><code>from_dict(fields)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def from_dict(self, fields: dict[str, Any]):\n    EventType, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    return EventType(**fields)\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.process_log","title":"process_log","text":"<pre><code>process_log(log)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def process_log(self, log: Log) -&gt; EventData[T]:\n    return EventData(\n        name=self.name,\n        log=log,\n        event=self.process(log.topics, log.data),\n        network=self._network or get_current_network(),\n    )\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.process","title":"process","text":"<pre><code>process(topics, data)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def process(self, topics: list[HexStr], data: HexStr) -&gt; T:\n    EventType, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    indexed = self.get_indexed()\n    try:\n        indexed_dict = {\n            name: self.process_value(type_, topics[i + 1])\n            for i, (name, type_) in enumerate(indexed)\n        }\n    except IndexError:\n        raise LogDecodeError(\"Mismatched Indexed values\")\n\n    unindexed = self.get_unindexed()\n    try:\n        unindexed_values = decode(\n            [type_ for (_, type_) in unindexed], bytes.fromhex(data[2:])\n        )\n    except InsufficientDataBytes:\n        raise LogDecodeError(\"Mismatched Unindexed values\")\n\n    return EventType(\n        **indexed_dict\n        | {name: val for (name, _), val in zip(unindexed, unindexed_values)}\n    )\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_indexed","title":"get_indexed","text":"<pre><code>get_indexed()\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def get_indexed(self):\n    inputs, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    input_types = inputs.model_fields\n    results = []\n    for name, field in input_types.items():\n        indexed = False\n        _type = field.annotation\n        annotations = field.metadata\n        for annotation in annotations:\n            if annotation == Indexed:\n                indexed = True\n            elif isinstance(annotation, Name):\n                name = annotation.value\n        if indexed:\n            results.append((name, map_type(_type)))\n    return results\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_unindexed","title":"get_unindexed","text":"<pre><code>get_unindexed()\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def get_unindexed(self):\n    inputs, *_ = self.__pydantic_generic_metadata__[\"args\"]\n    input_types = inputs.model_fields\n    results = []\n    for name, field in input_types.items():\n        indexed = False\n        _type = field.annotation\n        annotations = field.metadata\n        for annotation in annotations:\n            if annotation == Indexed:\n                indexed = True\n            elif isinstance(annotation, Name):\n                name = annotation.value\n        if not indexed:\n            results.append((name, convert(_type)))\n    return results\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.set_filter","title":"set_filter","text":"<pre><code>set_filter(\n    addresses=[],\n    topic1=IGNORE_VAL,\n    topic2=IGNORE_VAL,\n    topic3=IGNORE_VAL,\n)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>def set_filter(\n    self,\n    addresses: list[HexAddress] = [],\n    topic1: Optional[HexStr | list[HexStr]] | IGNORE = IGNORE_VAL,\n    topic2: Optional[HexStr | list[HexStr]] | IGNORE = IGNORE_VAL,\n    topic3: Optional[HexStr | list[HexStr]] | IGNORE = IGNORE_VAL,\n):\n    model = deepcopy(self)\n    model.addresses_filter = addresses\n    if topic1 != IGNORE_VAL:\n        model.topic1_filter = topic1\n    if topic2 != IGNORE_VAL:\n        model.topic1_filter = model.topic1_filter or None\n        model.topic2_filter = topic2\n    if topic3 != IGNORE_VAL:\n        model.topic1_filter = model.topic1_filter or None\n        model.topic2_filter = model.topic2_filter or None\n        model.topic3_filter = topic3\n    return model\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.get_logs","title":"get_logs  <code>async</code>","text":"<pre><code>get_logs(start_block, end_block)\n</code></pre> Source code in <code>eth_rpc/event.py</code> <pre><code>async def get_logs(\n    self,\n    start_block: BlockReference | int,\n    end_block: BlockReference | int,\n) -&gt; AsyncIterator[EventData[T]]:\n    cur_end = end_block\n    try:\n        response = await self._get_logs(\n            start_block,\n            cur_end,\n            self.addresses_filter,\n            topic1=self.topic1_filter,\n            topic2=self.topic2_filter,\n            topic3=self.topic3_filter,\n        )\n    except ValueError as err:\n        message = err.args[0]\n        if \"Log response size exceeded.\" in message:\n            boundaries = re.findall(\"0x[0-9a-f]+\", message)\n            raise LogResponseExceededError(\n                err.args[0], int(boundaries[0], 16), int(boundaries[1], 16)\n            )\n        raise err\n\n    for result in response:\n        # TODO: this is just a placeholder\n        if len(result.topics) != (len(self.get_indexed()) + 1):\n            # this happens when an event has the same topic0, but different indexed events so it doesn't match up to the expected ABI\n            continue\n\n        event_data = EventData[T](\n            name=self.name,\n            log=result,\n            event=self.process(\n                result.topics,\n                result.data,\n            ),\n            network=self._network or get_current_network(),\n        )\n        yield event_data\n</code></pre>"},{"location":"api/event/#eth_rpc.Event.backfill","title":"backfill  <code>async</code>","text":"<pre><code>backfill(start_block=None, end_block=None, step_size=None)\n</code></pre> <p>This backfills events, handling LogResponseExceededError to provide all logs in a range too large for a single request</p> Source code in <code>eth_rpc/event.py</code> <pre><code>async def backfill(\n    self,\n    start_block: int | None = None,\n    end_block: int | None = None,\n    step_size: Optional[int] = None,\n) -&gt; AsyncIterator[EventData[T]]:\n    \"\"\"\n    This backfills events, handling LogResponseExceededError to provide all logs in a range too large for a single request\n    \"\"\"\n    start_block = start_block or 1\n    current_number = await Block.get_number()\n    end_block = end_block or (current_number - 3)  # set 3 default confirmations\n\n    if start_block == \"earliest\":\n        cur_start = 0\n    else:\n        cur_start = start_block\n\n    if step_size:\n        cur_end = cur_start + step_size\n    else:\n        cur_end = end_block\n    while cur_start &lt;= end_block:\n        try:\n            async for log in self.get_logs(\n                start_block=cur_start,\n                end_block=min(cur_end, end_block),\n            ):\n                yield log\n        except LogResponseExceededError as err:\n            cur_end = err.recommended_end\n            continue\n        cur_start = cur_end + 1\n        if step_size:\n            cur_end += step_size\n        else:\n            cur_end = end_block\n</code></pre>"},{"location":"api/event_data/","title":"EventData","text":""},{"location":"api/event_data/#eth_rpc.EventData","title":"eth_rpc.EventData","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>This joins a log with it's transformed format (T). It needs to be in models because Models rely on Types.</p>"},{"location":"api/event_data/#eth_rpc.EventData.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.network","title":"network  <code>instance-attribute</code>","text":"<pre><code>network\n</code></pre>"},{"location":"api/event_data/#eth_rpc.EventData.tx","title":"tx  <code>property</code>","text":"<pre><code>tx\n</code></pre>"},{"location":"api/func/","title":"FuncSignature","text":""},{"location":"api/func/#eth_rpc.FuncSignature","title":"eth_rpc.FuncSignature","text":"<p>               Bases: <code>Request</code>, <code>Generic[T, U]</code></p>"},{"location":"api/func/#eth_rpc.FuncSignature.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias = None\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_identifier","title":"get_identifier","text":"<pre><code>get_identifier()\n</code></pre> <p>This works most of the time</p> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_identifier(self):\n    \"\"\"This works most of the time\"\"\"\n    signature = f'{self.name}({\",\".join(self.get_inputs())})'\n    return f\"0x{keccak_256(signature.encode('utf-8')).hex()[:8]}\"\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_inputs","title":"get_inputs","text":"<pre><code>get_inputs()\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_inputs(self):\n    from ..types import Struct\n\n    inputs, _ = self.__pydantic_generic_metadata__[\"args\"]\n    if inputs is NoArgs:\n        return []\n    if (\n        type(inputs) is not GenericAlias\n        and isclass(inputs)\n        and issubclass(inputs, BaseModel)\n    ):\n        converted_inputs = transform_primitive(inputs)\n        if issubclass(inputs, Struct):\n            converted_input_tuple = \",\".join(converted_inputs)\n            return [f\"({converted_input_tuple})\"]\n    else:\n        if get_origin(inputs) == list:\n            return [transform_primitive(inputs)]\n        elif get_origin(inputs) == tuple:\n            return tuple(transform_primitive(input) for input in get_args(inputs))\n        else:\n            converted_inputs = transform_primitive(inputs)\n    if not isinstance(converted_inputs, list):\n        return [converted_inputs]\n    return converted_inputs\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_output","title":"get_output","text":"<pre><code>get_output()\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_output(self):\n    outputs = self._output\n    if outputs is type(None):\n        return None\n\n    if is_annotation(outputs):\n        outputs = get_args(outputs)[0]\n\n    if (\n        isclass(outputs)\n        and not isinstance(outputs, GenericAlias)\n        and issubclass(outputs, BaseModel)\n    ):\n        converted_outputs = transform_primitive(outputs)\n    else:\n        converted_outputs = transform_primitive(outputs)\n    return converted_outputs\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.get_output_name","title":"get_output_name","text":"<pre><code>get_output_name()\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def get_output_name(self):\n    return [self._get_name(output) for output in get_args(self._output)]\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.encode_call","title":"encode_call","text":"<pre><code>encode_call(*, inputs)\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def encode_call(self, *, inputs: T) -&gt; HexStr:\n    from ..types import Struct\n\n    identifier = self.get_identifier()\n    # TODO: this is hard\n    if inputs == ():\n        return identifier\n\n    if isinstance(inputs, BaseModel):\n        if isinstance(inputs, Struct):\n            input_data = inputs.to_bytes().hex()\n        else:\n            input_data = encode(\n                self.get_inputs(),\n                list(inputs.model_dump().values()),\n            ).hex()\n    elif not isinstance(inputs, tuple):\n        input_data = encode(self.get_inputs(), [inputs]).hex()\n    else:\n        input_data = encode(self.get_inputs(), inputs).hex()\n    return HexStr(f\"{identifier}{input_data}\")\n</code></pre>"},{"location":"api/func/#eth_rpc.FuncSignature.decode_result","title":"decode_result","text":"<pre><code>decode_result(result)\n</code></pre> Source code in <code>eth_rpc/contract/func_signature.py</code> <pre><code>def decode_result(self, result: HexStr) -&gt; U:\n    output = self.get_output()\n    if output is None:\n        # return None if the expected return type is None\n        return output  # type: ignore\n\n    if not isinstance(output, list):\n        output = [output]\n        decoded_output = decode(output, bytes.fromhex(result.removeprefix(\"0x\")))[0]\n    else:\n        if isclass(self._output) and issubclass(self._output, Struct):\n            return self._output.from_bytes(bytes.fromhex(result.removeprefix(\"0x\")))\n        else:\n            decoded_output = decode(\n                output, bytes.fromhex(result.removeprefix(\"0x\"))\n            )\n\n    # NOTE: https://github.com/pydantic/pydantic/discussions/5970\n    # TODO: this is discussed to see if its a bug or not.  Annotations are a class but can't be checked as a subclass\n    if (\n        isclass(self._output)\n        and not isinstance(self._output, GenericAlias)\n        and issubclass(self._output, BaseModel)\n    ):\n        init_dict = {}\n        for (key, field_info), val in zip(\n            self._output.model_fields.items(), decoded_output\n        ):\n            init_dict[field_info.alias or key] = val\n        return self._output(**init_dict)  # type: ignore\n    return decoded_output\n</code></pre>"},{"location":"api/log/","title":"Log","text":""},{"location":"api/log/#eth_rpc.Log","title":"eth_rpc.Log","text":"<p>               Bases: <code>Request</code>, <code>Log</code></p>"},{"location":"api/log/#eth_rpc.Log.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.transaction_hash","title":"transaction_hash  <code>instance-attribute</code>","text":"<pre><code>transaction_hash\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.block_hash","title":"block_hash  <code>instance-attribute</code>","text":"<pre><code>block_hash\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.block_number","title":"block_number  <code>instance-attribute</code>","text":"<pre><code>block_number\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.log_index","title":"log_index  <code>instance-attribute</code>","text":"<pre><code>log_index\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.removed","title":"removed  <code>instance-attribute</code>","text":"<pre><code>removed\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.topics","title":"topics  <code>instance-attribute</code>","text":"<pre><code>topics\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.transaction_index","title":"transaction_index  <code>instance-attribute</code>","text":"<pre><code>transaction_index\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.set_network","title":"set_network","text":"<pre><code>set_network(network)\n</code></pre> Source code in <code>eth_rpc/utils/model.py</code> <pre><code>def set_network(self, network: type[Network] | None):\n    object.__setattr__(self, \"_network\", network)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.load_by_number","title":"load_by_number  <code>classmethod</code>","text":"<pre><code>load_by_number(from_block, to_block=None)\n</code></pre> Source code in <code>eth_rpc/log.py</code> <pre><code>@classmethod\ndef load_by_number(\n    self,\n    from_block: int | HexInt,\n    to_block: int | HexInt | None = None,\n) -&gt; RPCResponseModel[LogsArgs, list[\"LogModel\"]]:\n    return RPCResponseModel(\n        self.rpc().get_logs,\n        LogsArgs(\n            params=LogsParams(\n                from_block=HexInt(from_block),\n                to_block=HexInt(to_block or from_block + 1),\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.listen","title":"listen  <code>async</code> <code>classmethod</code>","text":"<pre><code>listen(*, queue, publish_logs=DEFAULT_EVENT)\n</code></pre> Source code in <code>eth_rpc/log.py</code> <pre><code>@classmethod\nasync def listen(\n    cls,\n    *,\n    queue: asyncio.Queue[\"LogModel\"],\n    publish_logs: asyncio.Event = DEFAULT_EVENT,\n):\n    internal_queue: asyncio.Queue = asyncio.Queue()\n    flush_queue: bool = True\n    async for log in cls._listen():\n        if publish_logs.is_set():\n            if flush_queue:\n                while not internal_queue.empty():\n                    staged_block = await internal_queue.get()\n                    await queue.put(staged_block)\n                flush_queue = False\n            await queue.put(log)\n        else:\n            await internal_queue.put(log)\n</code></pre>"},{"location":"api/log/#eth_rpc.Log.subscribe_from","title":"subscribe_from  <code>async</code> <code>classmethod</code>","text":"<pre><code>subscribe_from(start_block=None, batch_size=50)\n</code></pre> Source code in <code>eth_rpc/log.py</code> <pre><code>@classmethod\nasync def subscribe_from(\n    self,\n    start_block: int | None = None,\n    batch_size: int = 50,\n) -&gt; AsyncIterator[LogModel]:\n    queue = asyncio.Queue[LogModel]()\n    should_publish_logs = asyncio.Event()\n    asyncio.create_task(\n        self.listen(\n            queue=queue,\n            publish_logs=should_publish_logs,\n        )\n    )\n    latest = await Block.get_number()\n    if not start_block:\n        start_block = latest\n    assert start_block\n\n    num = start_block\n    while num &lt;= latest:\n        batch_end = min(num + batch_size, latest)\n        for log in await self.load_by_number(num, batch_end):\n            yield log\n        num += batch_size\n\n    should_publish_logs.set()\n    while True:\n        log = await queue.get()\n        if log.block_number &gt; latest:\n            yield log\n</code></pre>"},{"location":"api/network/","title":"Network","text":""},{"location":"api/network/#eth_rpc.types.Network","title":"eth_rpc.types.Network","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/network/#eth_rpc.types.Network.http","title":"http  <code>class-attribute</code>","text":"<pre><code>http\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.wss","title":"wss  <code>class-attribute</code>","text":"<pre><code>wss\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.chain_id","title":"chain_id  <code>class-attribute</code>","text":"<pre><code>chain_id\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.native_currency","title":"native_currency  <code>class-attribute</code>","text":"<pre><code>native_currency\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.rpc","title":"rpc  <code>class-attribute</code>","text":"<pre><code>rpc\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.block_explorer","title":"block_explorer  <code>class-attribute</code>","text":"<pre><code>block_explorer\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.alchemy_str","title":"alchemy_str  <code>class-attribute</code>","text":"<pre><code>alchemy_str = None\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.multicall3","title":"multicall3  <code>class-attribute</code>","text":"<pre><code>multicall3 = HexAddress(\n    HexStr(\"0xca11bde05977b3631167028862be2a173976ca11\")\n)\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.ens_registry","title":"ens_registry  <code>class-attribute</code>","text":"<pre><code>ens_registry = HexAddress(\n    HexStr(\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\")\n)\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.ens_universal_resolver","title":"ens_universal_resolver  <code>class-attribute</code>","text":"<pre><code>ens_universal_resolver = HexAddress(\n    HexStr(\"0xce01f8eee7E479C928F8919abD53E553a36CeF67\")\n)\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.apprx_block_time","title":"apprx_block_time  <code>class-attribute</code>","text":"<pre><code>apprx_block_time = 12.0\n</code></pre>"},{"location":"api/network/#eth_rpc.types.Network.set","title":"set  <code>classmethod</code>","text":"<pre><code>set(http=None, wss=None, api_key=None)\n</code></pre> Source code in <code>eth_rpc/types/network.py</code> <pre><code>@classmethod\ndef set(\n    cls,\n    http: str | None = None,\n    wss: str | None = None,\n    api_key: str | None = None,\n):\n    if http:\n        cls.rpc.default.http = Url(http)\n        cls.http = str(cls.rpc.default.http)\n    if wss:\n        cls.rpc.default.wss = Url(wss)\n        cls.wss = str(cls.rpc.default.wss)\n    if api_key:\n        cls.block_explorer.api_key = api_key\n    return cls\n</code></pre>"},{"location":"api/protocol/","title":"ProtocolBase","text":""},{"location":"api/protocol/#eth_rpc.ProtocolBase","title":"eth_rpc.ProtocolBase","text":"<pre><code>ProtocolBase(**kwargs)\n</code></pre> <p>               Bases: <code>_ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/protocol/#eth_rpc.ProtocolBase.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/transaction/","title":"Transaction","text":""},{"location":"api/transaction/#eth_rpc.Transaction","title":"eth_rpc.Transaction","text":"<p>               Bases: <code>Request</code>, <code>Transaction</code>, <code>Generic[Network]</code></p>"},{"location":"api/transaction/#eth_rpc.Transaction.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.hash","title":"hash  <code>instance-attribute</code>","text":"<pre><code>hash\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.access_list","title":"access_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>access_list = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.chain_id","title":"chain_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chain_id = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.from_","title":"from_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>from_ = Field(alias='from')\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.gas","title":"gas  <code>instance-attribute</code>","text":"<pre><code>gas\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.gas_price","title":"gas_price  <code>instance-attribute</code>","text":"<pre><code>gas_price\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.max_fee_per_gas","title":"max_fee_per_gas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_fee_per_gas = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.max_priority_fee_per_gas","title":"max_priority_fee_per_gas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_priority_fee_per_gas = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.nonce","title":"nonce  <code>instance-attribute</code>","text":"<pre><code>nonce\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.r","title":"r  <code>instance-attribute</code>","text":"<pre><code>r\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.s","title":"s  <code>instance-attribute</code>","text":"<pre><code>s\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.v","title":"v  <code>instance-attribute</code>","text":"<pre><code>v\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.to","title":"to  <code>instance-attribute</code>","text":"<pre><code>to\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.y_parity","title":"y_parity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_parity = None\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.block_hash","title":"block_hash  <code>instance-attribute</code>","text":"<pre><code>block_hash\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.block_number","title":"block_number  <code>instance-attribute</code>","text":"<pre><code>block_number\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.transaction_index","title":"transaction_index  <code>instance-attribute</code>","text":"<pre><code>transaction_index\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_block","title":"get_block","text":"<pre><code>get_block(with_tx_data=False)\n</code></pre> Source code in <code>eth_rpc/models/transaction.py</code> <pre><code>def get_block(self, with_tx_data: bool = False):\n    from eth_rpc.block import Block\n\n    \"\"\"Load a block hash\"\"\"\n\n    return Block.load_by_hash(self.block_hash, with_tx_data=with_tx_data)\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_by_hash","title":"get_by_hash  <code>classmethod</code>","text":"<pre><code>get_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, Optional[\"Transaction[Network]\"]]:\n    return RPCResponseModel(\n        self.rpc().get_tx_by_hash,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_pending_by_hash","title":"get_pending_by_hash  <code>classmethod</code>","text":"<pre><code>get_pending_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_pending_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, PendingTransaction]:\n    return RPCResponseModel(\n        self.rpc().get_pending_tx_by_hash,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_receipt_by_hash","title":"get_receipt_by_hash  <code>classmethod</code>","text":"<pre><code>get_receipt_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_receipt_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, \"Transaction[Network]\"]:\n    return RPCResponseModel(\n        self.rpc().get_tx_receipt,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.get_by_index","title":"get_by_index  <code>classmethod</code>","text":"<pre><code>get_by_index(\n    transaction_index, block_hash=None, block_number=None\n)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_by_index(\n    self,\n    transaction_index: int,\n    block_hash: HexStr | None = None,\n    block_number: int | BLOCK_STRINGS | None = None,\n) -&gt; RPCResponseModel[\n    GetTransactionByBlockHash | GetTransactionByBlockNumber, \"Transaction[Network]\"\n]:\n    if block_hash is None and block_number is None:\n        raise ValueError(\"Must provide either block_hash or block_number\")\n    if block_hash:\n        return RPCResponseModel(\n            self.rpc().get_tx_by_block_hash,\n            GetTransactionByBlockHash(\n                block_hash=block_hash,\n                index=HexInteger(transaction_index),\n            ),\n        )\n    block_number = cast(int | BLOCK_STRINGS, block_number)\n    return RPCResponseModel(\n        self.rpc().get_tx_by_block_number,\n        GetTransactionByBlockNumber(\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n            index=HexInteger(transaction_index),\n        ),\n    )\n</code></pre>"},{"location":"api/transaction/#eth_rpc.Transaction.subscribe_pending","title":"subscribe_pending  <code>async</code> <code>classmethod</code>","text":"<pre><code>subscribe_pending()\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\nasync def subscribe_pending(  # noqa: C901\n    self,\n) -&gt; AsyncIterator[PendingTransaction]:  # noqa: C901\n    rpc = _force_get_global_rpc()\n    async for w3_connection in connect(\n        rpc.wss,\n        ping_interval=60,\n        ping_timeout=60,\n        max_queue=10000,\n        open_timeout=30,\n    ):\n        try:\n            await self._send_subscription_request(\n                w3_connection,\n            )\n            subscription_response: SubscriptionResponse = json.loads(\n                await w3_connection.recv()\n            )\n            if not subscription_response[\"result\"]:\n                raise ValueError(subscription_response)\n        except Exception as e:\n            raise e\n\n        while True:\n            try:\n                message = await asyncio.wait_for(w3_connection.recv(), timeout=32.0)\n                message_json: JsonPendingWssResponse = json.loads(message)\n                if \"params\" not in message_json:\n                    raise ValueError(message_json)\n\n                transaction_hash: HexStr = message_json[\"params\"][\"result\"]\n                transaction = await self.get_pending_by_hash(transaction_hash)\n                if transaction:\n                    yield transaction\n            except asyncio.exceptions.TimeoutError:\n                pass\n            except (\n                ConnectionClosedError,\n                ConnectionResetError,\n                OSError,  # No route to host\n                asyncio.exceptions.IncompleteReadError,  # TODO: should this be handled differently?\n            ) as err:\n                logger.error(\"connection terminated unexpectedly: %s\", err)\n                await asyncio.sleep(1)\n                # we're in an iterator, so make a new connection and continue listening\n                break\n            except Exception as err:\n                logger.error(\"unknown connection error: %s\", err)\n                await asyncio.sleep(1)\n                # we're in an iterator, so make a new connection and continue listening\n                break\n</code></pre>"},{"location":"api/transaction_receipt/","title":"Transaction Receipt","text":""},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt","title":"eth_rpc.TransactionReceipt","text":"<p>               Bases: <code>Request</code>, <code>TransactionReceipt</code>, <code>Generic[Network]</code></p>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    alias_generator=to_camel,\n    populate_by_name=True,\n    from_attributes=True,\n)\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.transaction_hash","title":"transaction_hash  <code>instance-attribute</code>","text":"<pre><code>transaction_hash\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.block_hash","title":"block_hash  <code>instance-attribute</code>","text":"<pre><code>block_hash\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.block_number","title":"block_number  <code>instance-attribute</code>","text":"<pre><code>block_number\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.logs","title":"logs  <code>instance-attribute</code>","text":"<pre><code>logs\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.contract_address","title":"contract_address  <code>instance-attribute</code>","text":"<pre><code>contract_address\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.effective_gas_price","title":"effective_gas_price  <code>instance-attribute</code>","text":"<pre><code>effective_gas_price\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.cumulative_gas_used","title":"cumulative_gas_used  <code>instance-attribute</code>","text":"<pre><code>cumulative_gas_used\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.from_","title":"from_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>from_ = Field(alias='from')\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.gas_used","title":"gas_used  <code>instance-attribute</code>","text":"<pre><code>gas_used\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.logs_bloom","title":"logs_bloom  <code>instance-attribute</code>","text":"<pre><code>logs_bloom\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status = None\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.to","title":"to  <code>instance-attribute</code>","text":"<pre><code>to\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.transaction_index","title":"transaction_index  <code>instance-attribute</code>","text":"<pre><code>transaction_index\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.has_log","title":"has_log","text":"<pre><code>has_log(topic)\n</code></pre> <p>Checks is a transaction has a topic in it</p> Source code in <code>eth_rpc/models/transaction_receipt.py</code> <pre><code>def has_log(self, topic: HexStr):\n    \"\"\"Checks is a transaction has a topic in it\"\"\"\n    t = bytes.fromhex(topic.replace(\"0x\", \"\"))\n\n    return t in BloomFilter(self.logs_bloom)\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.get_by_hash","title":"get_by_hash  <code>classmethod</code>","text":"<pre><code>get_by_hash(tx_hash)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_by_hash(\n    self, tx_hash: HexStr\n) -&gt; RPCResponseModel[TransactionRequest, Optional[TransactionReceiptModel]]:\n    return RPCResponseModel(\n        self.rpc().get_tx_receipt,\n        TransactionRequest(\n            tx_hash=tx_hash,\n        ),\n    )\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.get_block_receipts","title":"get_block_receipts  <code>classmethod</code>","text":"<pre><code>get_block_receipts(block_number=None, block_hash=None)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef get_block_receipts(\n    self,\n    block_number: Optional[int] = None,\n    block_hash: Optional[HexStr] = None,\n) -&gt; RPCResponseModel[list[HexStr], list[TransactionReceiptModel]]:\n    if block_number:\n        param = hex(block_number)\n    elif block_hash:\n        param = block_hash\n    return RPCResponseModel(\n        self.rpc().get_block_receipts,\n        [HexStr(param)],\n    )\n</code></pre>"},{"location":"api/transaction_receipt/#eth_rpc.TransactionReceipt.alchemy_get_block_receipts","title":"alchemy_get_block_receipts  <code>classmethod</code>","text":"<pre><code>alchemy_get_block_receipts(\n    block_number=None, block_hash=None\n)\n</code></pre> Source code in <code>eth_rpc/transaction.py</code> <pre><code>@classmethod\ndef alchemy_get_block_receipts(\n    self,\n    block_number: Optional[int] = None,\n    block_hash: Optional[HexStr] = None,\n) -&gt; RPCResponseModel[AlchemyBlockReceipt, \"AlchemyReceiptsResponse\"]:\n    return RPCResponseModel(\n        self.rpc().alchemy_get_block_receipts,\n        AlchemyBlockReceipt(\n            params=AlchemyParams(\n                block_number=HexInteger(block_number) if block_number else None,\n                block_hash=block_hash,\n            )\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/","title":"Wallet","text":""},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet","title":"eth_rpc.PrivateKeyWallet","text":"<p>               Bases: <code>BaseWallet</code></p>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.private_key","title":"private_key  <code>instance-attribute</code>","text":"<pre><code>private_key\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.address","title":"address  <code>property</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.get_nonce","title":"get_nonce","text":"<pre><code>get_nonce(block_number='latest')\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def get_nonce(self, block_number: int | BLOCK_STRINGS = \"latest\"):\n    return RPCResponseModel(\n        self.rpc().get_tx_count,\n        GetAccountArgs(\n            address=self.address,\n            block_number=(\n                HexInteger(block_number)\n                if isinstance(block_number, int)\n                else block_number\n            ),\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    self._account = Account.from_key(self.private_key)\n    return super().model_post_init(__context)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.get_pvt_key","title":"get_pvt_key  <code>staticmethod</code>","text":"<pre><code>get_pvt_key()\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@staticmethod\ndef get_pvt_key() -&gt; HexStr:\n    priv = secrets.token_hex(32)\n    return HexStr(f\"0x{priv}\")\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.create_new","title":"create_new  <code>classmethod</code>","text":"<pre><code>create_new()\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@classmethod\ndef create_new(cls):\n    return cls(private_key=cls.get_pvt_key())\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.sign_transaction","title":"sign_transaction","text":"<pre><code>sign_transaction(tx)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def sign_transaction(self, tx: PreparedTransaction) -&gt; SignedTransaction:\n    signed_tx = self._account.sign_transaction(tx.model_dump())\n    return SignedTransaction(\n        raw_transaction=signed_tx[0].hex(),\n        hash=signed_tx.hash.hex(),\n        r=signed_tx.r,\n        s=signed_tx.s,\n        v=signed_tx.v,\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.send_raw_transaction","title":"send_raw_transaction","text":"<pre><code>send_raw_transaction(tx)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def send_raw_transaction(\n    self, tx: HexStr\n) -&gt; RPCResponseModel[RawTransaction, HexStr]:\n    return RPCResponseModel(\n        self.rpc().send_raw_tx,\n        RawTransaction(\n            signed_tx=tx,\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.prepare_and_sign","title":"prepare_and_sign","text":"<pre><code>prepare_and_sign(\n    *,\n    to,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    data=HexStr(\"0x\"),\n    nonce=None\n)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def prepare_and_sign(\n    self,\n    *,\n    to: HexAddress,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    data: HexStr = HexStr(\"0x\"),\n    nonce: Optional[int] = None,\n):\n    prepared = self.prepare(\n        to=to,\n        value=value,\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        data=data,\n        nonce=nonce,\n    )\n    return self.sign_transaction(prepared)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.prepare","title":"prepare","text":"<pre><code>prepare(\n    *,\n    to,\n    value=0,\n    max_fee_per_gas=None,\n    max_priority_fee_per_gas=None,\n    data=HexStr(\"0x\"),\n    nonce=None\n)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def prepare(\n    self,\n    *,\n    to: HexAddress,\n    value: int = 0,\n    max_fee_per_gas: Optional[int] = None,\n    max_priority_fee_per_gas: Optional[int] = None,\n    data: HexStr = HexStr(\"0x\"),\n    nonce: Optional[int] = None,\n):\n    # TODO: this assumes sync\n    gas = self.estimate_gas(to=to, data=data).sync\n    access_list = None\n    rpc = _force_get_global_rpc()\n    chain_id = rpc.chain_id.sync()\n\n    max_priority_fee_per_gas = max_priority_fee_per_gas or Block.priority_fee().sync\n    base_fee_per_gas = Block.pending().sync.base_fee_per_gas\n    assert base_fee_per_gas, \"block is earlier than London Hard Fork\"\n    max_fee_per_gas = max_fee_per_gas or (\n        2 * base_fee_per_gas + max_priority_fee_per_gas\n    )\n\n    return PreparedTransaction(\n        data=data,\n        to=to,\n        gas=HexInteger(gas),\n        max_fee_per_gas=max_fee_per_gas,\n        max_priority_fee_per_gas=max_priority_fee_per_gas,\n        nonce=nonce or self.get_nonce().sync,\n        value=value,\n        access_list=access_list,\n        chain_id=chain_id,\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.estimate_gas","title":"estimate_gas","text":"<pre><code>estimate_gas(to, block_number='latest', data=HexStr('0x'))\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def estimate_gas(\n    self,\n    to: HexAddress,\n    block_number: HexInteger | Literal[\"latest\", \"pending\"] = \"latest\",\n    data: HexStr = HexStr(\"0x\"),\n) -&gt; RPCResponseModel[CallWithBlockArgs, HexInteger]:\n    return RPCResponseModel(\n        self.rpc().estimate_gas,\n        CallWithBlockArgs(\n            params=EthCallParams(\n                from_=self.address,\n                to=to,\n                data=data,\n            ),\n            block_number=block_number,\n        ),\n    )\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.transfer","title":"transfer","text":"<pre><code>transfer(to, value)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def transfer(self, to: HexAddress, value: int):\n    prepared_tx = self.prepare(to=to, value=value)\n    signed_tx = self.sign_transaction(prepared_tx)\n    return self.send_raw_transaction(HexStr(\"0x\" + signed_tx.raw_transaction)).sync\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.sign_hash","title":"sign_hash","text":"<pre><code>sign_hash(hashed)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>def sign_hash(self, hashed: bytes) -&gt; SignedMessage:\n    return Account._sign_hash(hashed, self._account.key)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.rsv_to_signature","title":"rsv_to_signature  <code>staticmethod</code>","text":"<pre><code>rsv_to_signature(r, s, v)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@staticmethod\ndef rsv_to_signature(r: int, s: int, v: int) -&gt; HexStr:\n    rr = hex(r)[2:].zfill(64)\n    ss = hex(s)[2:].zfill(64)\n    vv = hex(v)[2:]\n    return HexStr(\"0x\" + rr + ss + vv)\n</code></pre>"},{"location":"api/wallet/#eth_rpc.PrivateKeyWallet.signature_to_rsv","title":"signature_to_rsv  <code>staticmethod</code>","text":"<pre><code>signature_to_rsv(signature)\n</code></pre> Source code in <code>eth_rpc/wallet.py</code> <pre><code>@staticmethod\ndef signature_to_rsv(signature: HexStr) -&gt; tuple[int, int, int]:\n    v = signature[-2:]\n    s = signature[-66:-2]\n    r = signature[:-66].lstrip(\"0x\")\n\n    return int(r, 16), int(s, 16), int(v, 16)\n</code></pre>"},{"location":"api/typeshed/erc20/","title":"ERC20","text":""},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20","title":"eth_typeshed.ERC20","text":"<pre><code>ERC20(**kwargs)\n</code></pre> <p>               Bases: <code>ERC20Metadata</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.decimals","title":"decimals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decimals = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.balance_of","title":"balance_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>balance_of = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.total_supply","title":"total_supply  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_supply = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.transfer","title":"transfer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transfer = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.transfer_from","title":"transfer_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transfer_from = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.approve","title":"approve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>approve = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.allowance","title":"allowance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowance = METHOD\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_decimals","title":"get_decimals","text":"<pre><code>get_decimals()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_decimals(self):\n    if not self._decimals:\n        self._decimals = self.decimals().get()\n    return self._decimals\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_name(self):\n    if not self._name:\n        self._name = self.name().get()\n    return self._name\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_symbol","title":"get_symbol","text":"<pre><code>get_symbol()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_symbol(self):\n    if not self._symbol:\n        self._symbol = self.symbol().get()\n    return self._symbol\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.load_async","title":"load_async  <code>async</code>","text":"<pre><code>load_async()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>async def load_async(self):\n    from eth_typeshed.multicall import multicall\n\n    if not (self._name and self._symbol and self._decimals):\n        self._name, self._symbol, self._decimals = await multicall.execute(\n            self.name(),\n            self.symbol(),\n            self.decimals(),\n        )\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_allowance_slot","title":"get_allowance_slot","text":"<pre><code>get_allowance_slot(owner, spender)\n</code></pre> <p>Gets the allowance slot given token/owner/spender combination</p> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_allowance_slot(self, owner: str, spender: str):\n    \"\"\"\n    Gets the allowance slot given token/owner/spender combination\n    \"\"\"\n    response = self._get_debug_tracecall(\n        self.address,\n        data=f\"0xdd62ed3e000000000000000000000000{owner.replace('0x', '')}000000000000000000000000{spender.replace('0x', '')}\",\n    )\n    if not response:\n        return None\n    try:\n        storage = response[self.address.lower()][\"storage\"]\n    except KeyError:\n        return None\n\n    for key in [\n        OZ_IMPLEMENTATION_SLOT,\n        ADMIN_SLOT,\n        EIP1967_IMPLEMENTATION_SLOT,\n    ]:\n        if hex(key) in storage:\n            del storage[hex(key)]\n    if len(storage) != 1:\n        # TOOD: this isn't really a ValueError, but we need to allow the client to handle this differently\n        raise ValueError(list(storage.keys()))\n    return list(storage.keys())[0]\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.get_balance_slot","title":"get_balance_slot","text":"<pre><code>get_balance_slot(owner)\n</code></pre> <p>Attempts to find the balance slot for an address. This will not work on tokens with irregular balance calculation.</p> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_balance_slot(self, owner: primitives.address) -&gt; Optional[HexStr]:\n    \"\"\"\n    Attempts to find the balance slot for an address.\n    This will not work on tokens with irregular balance calculation.\n    \"\"\"\n    balance = self.balance_of(owner).sync.call().raw\n    result = self._get_debug_tracecall(\n        self.address,\n        data=f\"0x70a08231000000000000000000000000{owner.replace('0x', '')}\",\n    )\n    storage = result[self.address.lower()][\"storage\"]\n    for slot in storage:\n        if balance in storage[slot]:\n            return slot\n\n    # Unknown slot return None\n    return None\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.balance_state_diff","title":"balance_state_diff","text":"<pre><code>balance_state_diff(owner, balance)\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def balance_state_diff(\n    self, owner: primitives.address, balance: int\n) -&gt; Optional[dict]:\n    slot = self.get_balance_slot(owner)\n    if slot:\n        return {\n            self.address: {\n                \"stateDiff\": {\n                    slot: to_bytes32(balance),\n                },\n            },\n        }\n    return {}\n</code></pre>"},{"location":"api/typeshed/erc20/#eth_typeshed.ERC20.allowance_state_diff","title":"allowance_state_diff","text":"<pre><code>allowance_state_diff(owner, spender, amount)\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def allowance_state_diff(\n    self, owner: HexAddress, spender: HexAddress, amount: int\n) -&gt; Optional[dict]:\n    slot = self.get_allowance_slot(owner, spender)\n    if slot:\n        return {\n            self.address: {\n                \"stateDiff\": {\n                    slot: to_bytes32(amount),\n                }\n            },\n        }\n    return {}\n</code></pre>"},{"location":"api/typeshed/multicall/","title":"Multicall","text":""},{"location":"api/typeshed/multicall/#eth_typeshed.multicall","title":"eth_typeshed.multicall","text":""},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=tuple[Any])\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.U","title":"U  <code>module-attribute</code>","text":"<pre><code>U = TypeVar('U')\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.MULTICALL3_ADDRESS","title":"MULTICALL3_ADDRESS  <code>module-attribute</code>","text":"<pre><code>MULTICALL3_ADDRESS = HexAddress(\n    HexStr(\"0xcA11bde05977b3631167028862bE2a173976CA11\")\n)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.multicall","title":"multicall  <code>module-attribute</code>","text":"<pre><code>multicall = Multicall(address=MULTICALL3_ADDRESS)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallRequest","title":"TryMulticallRequest","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallRequest.require_success","title":"require_success  <code>instance-attribute</code>","text":"<pre><code>require_success\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallRequest.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.MulticallRequest","title":"MulticallRequest","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.MulticallRequest.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallResponse","title":"TryMulticallResponse","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallResponse.block_number","title":"block_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block_number = Field(alias='blockNumber')\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallResponse.block_hash","title":"block_hash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block_hash = Field(alias='blockHash')\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryMulticallResponse.return_data","title":"return_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>return_data = Field(alias='returnData')\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryResult","title":"TryResult","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryResult.success","title":"success  <code>instance-attribute</code>","text":"<pre><code>success\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.TryResult.result","title":"result  <code>instance-attribute</code>","text":"<pre><code>result\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall","title":"Multicall","text":"<pre><code>Multicall(**kwargs)\n</code></pre> <p>               Bases: <code>ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.address","title":"address  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>address = Field(default=MULTICALL3_ADDRESS)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.block_and_aggregate","title":"block_and_aggregate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block_and_aggregate = METHOD\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.try_block_and_aggregate","title":"try_block_and_aggregate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>try_block_and_aggregate = METHOD\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.execute","title":"execute","text":"<pre><code>execute(*calls, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_typeshed/multicall.py</code> <pre><code>def execute(\n    self,\n    *calls: ContractFunc,\n    block_number: int | BLOCK_STRINGS = \"latest\",\n    sync: bool = False,\n) -&gt; MaybeAwaitable[list[Any]]:\n    return run(self._execute, *calls, block_number=block_number, sync=sync)\n</code></pre>"},{"location":"api/typeshed/multicall/#eth_typeshed.multicall.Multicall.try_execute","title":"try_execute","text":"<pre><code>try_execute(\n    *calls,\n    require_success=False,\n    sync=False,\n    block_number=\"latest\"\n)\n</code></pre> Source code in <code>eth_typeshed/multicall.py</code> <pre><code>def try_execute(\n    self,\n    *calls: ContractFunc,\n    require_success: bool = False,\n    sync: bool = False,\n    block_number: int | BLOCK_STRINGS = \"latest\",\n) -&gt; MaybeAwaitable[list[TryResult]]:\n    return run(\n        self._try_execute,\n        *calls,\n        require_success=require_success,\n        sync=sync,\n        block_number=block_number,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/","title":"UniswapV2","text":""},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2","title":"eth_typeshed.uniswap_v2","text":""},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2BurnEvent","title":"V2BurnEvent  <code>module-attribute</code>","text":"<pre><code>V2BurnEvent = Event[V2BurnEventType](name='Burn')\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2MintEvent","title":"V2MintEvent  <code>module-attribute</code>","text":"<pre><code>V2MintEvent = Event[V2MintEventType](name='Mint')\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2PairCreatedEvent","title":"V2PairCreatedEvent  <code>module-attribute</code>","text":"<pre><code>V2PairCreatedEvent = Event[V2PairCreatedEventType](\n    name=\"PairCreated\"\n)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEvent","title":"V2SwapEvent  <code>module-attribute</code>","text":"<pre><code>V2SwapEvent = Event[V2SwapEventType](name='Swap')\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SyncEvent","title":"V2SyncEvent  <code>module-attribute</code>","text":"<pre><code>V2SyncEvent = Event[V2SyncEventType](name='Sync')\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2FactoryAddresses","title":"UniswapV2FactoryAddresses","text":""},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2FactoryAddresses.Ethereum","title":"Ethereum","text":""},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2FactoryAddresses.Ethereum.Uniswap","title":"Uniswap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Uniswap = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f'\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2FactoryAddresses.Ethereum.SushiSwap","title":"SushiSwap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SushiSwap = '0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac'\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2BurnEventType","title":"V2BurnEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2BurnEventType.sender","title":"sender  <code>instance-attribute</code>","text":"<pre><code>sender\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2BurnEventType.amount0","title":"amount0  <code>instance-attribute</code>","text":"<pre><code>amount0\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2BurnEventType.amount1","title":"amount1  <code>instance-attribute</code>","text":"<pre><code>amount1\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2BurnEventType.to","title":"to  <code>instance-attribute</code>","text":"<pre><code>to\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2MintEventType","title":"V2MintEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2MintEventType.sender","title":"sender  <code>instance-attribute</code>","text":"<pre><code>sender\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2MintEventType.amount0","title":"amount0  <code>instance-attribute</code>","text":"<pre><code>amount0\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2MintEventType.amount1","title":"amount1  <code>instance-attribute</code>","text":"<pre><code>amount1\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2PairCreatedEventType","title":"V2PairCreatedEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2PairCreatedEventType.token0","title":"token0  <code>instance-attribute</code>","text":"<pre><code>token0\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2PairCreatedEventType.token1","title":"token1  <code>instance-attribute</code>","text":"<pre><code>token1\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2PairCreatedEventType.pair","title":"pair  <code>instance-attribute</code>","text":"<pre><code>pair\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2PairCreatedEventType.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType","title":"V2SwapEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType.sender","title":"sender  <code>instance-attribute</code>","text":"<pre><code>sender\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType.amount0_in","title":"amount0_in  <code>instance-attribute</code>","text":"<pre><code>amount0_in\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType.amount1_in","title":"amount1_in  <code>instance-attribute</code>","text":"<pre><code>amount1_in\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType.amount0_out","title":"amount0_out  <code>instance-attribute</code>","text":"<pre><code>amount0_out\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType.amount1_out","title":"amount1_out  <code>instance-attribute</code>","text":"<pre><code>amount1_out\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SwapEventType.to","title":"to  <code>instance-attribute</code>","text":"<pre><code>to\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SyncEventType","title":"V2SyncEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SyncEventType.reserve0","title":"reserve0  <code>instance-attribute</code>","text":"<pre><code>reserve0\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.V2SyncEventType.reserve1","title":"reserve1  <code>instance-attribute</code>","text":"<pre><code>reserve1\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.GetPairRequest","title":"GetPairRequest","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.GetPairRequest.token_a","title":"token_a  <code>instance-attribute</code>","text":"<pre><code>token_a\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.GetPairRequest.token_b","title":"token_b  <code>instance-attribute</code>","text":"<pre><code>token_b\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory","title":"UniswapV2Factory","text":"<pre><code>UniswapV2Factory(**kwargs)\n</code></pre> <p>               Bases: <code>ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.get_pair","title":"get_pair  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_pair = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Factory.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair","title":"UniswapV2Pair","text":"<pre><code>UniswapV2Pair(**kwargs)\n</code></pre> <p>               Bases: <code>ERC20</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.decimals","title":"decimals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decimals = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.balance_of","title":"balance_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>balance_of = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.total_supply","title":"total_supply  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_supply = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.transfer","title":"transfer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transfer = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.transfer_from","title":"transfer_from  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transfer_from = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.approve","title":"approve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>approve = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.allowance","title":"allowance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowance = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_reserves","title":"get_reserves  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_reserves = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.token0","title":"token0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token0 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.token1","title":"token1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token1 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_decimals","title":"get_decimals","text":"<pre><code>get_decimals()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_decimals(self):\n    if not self._decimals:\n        self._decimals = self.decimals().get()\n    return self._decimals\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_name(self):\n    if not self._name:\n        self._name = self.name().get()\n    return self._name\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_symbol","title":"get_symbol","text":"<pre><code>get_symbol()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_symbol(self):\n    if not self._symbol:\n        self._symbol = self.symbol().get()\n    return self._symbol\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.load_async","title":"load_async  <code>async</code>","text":"<pre><code>load_async()\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>async def load_async(self):\n    from eth_typeshed.multicall import multicall\n\n    if not (self._name and self._symbol and self._decimals):\n        self._name, self._symbol, self._decimals = await multicall.execute(\n            self.name(),\n            self.symbol(),\n            self.decimals(),\n        )\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_allowance_slot","title":"get_allowance_slot","text":"<pre><code>get_allowance_slot(owner, spender)\n</code></pre> <p>Gets the allowance slot given token/owner/spender combination</p> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_allowance_slot(self, owner: str, spender: str):\n    \"\"\"\n    Gets the allowance slot given token/owner/spender combination\n    \"\"\"\n    response = self._get_debug_tracecall(\n        self.address,\n        data=f\"0xdd62ed3e000000000000000000000000{owner.replace('0x', '')}000000000000000000000000{spender.replace('0x', '')}\",\n    )\n    if not response:\n        return None\n    try:\n        storage = response[self.address.lower()][\"storage\"]\n    except KeyError:\n        return None\n\n    for key in [\n        OZ_IMPLEMENTATION_SLOT,\n        ADMIN_SLOT,\n        EIP1967_IMPLEMENTATION_SLOT,\n    ]:\n        if hex(key) in storage:\n            del storage[hex(key)]\n    if len(storage) != 1:\n        # TOOD: this isn't really a ValueError, but we need to allow the client to handle this differently\n        raise ValueError(list(storage.keys()))\n    return list(storage.keys())[0]\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_balance_slot","title":"get_balance_slot","text":"<pre><code>get_balance_slot(owner)\n</code></pre> <p>Attempts to find the balance slot for an address. This will not work on tokens with irregular balance calculation.</p> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def get_balance_slot(self, owner: primitives.address) -&gt; Optional[HexStr]:\n    \"\"\"\n    Attempts to find the balance slot for an address.\n    This will not work on tokens with irregular balance calculation.\n    \"\"\"\n    balance = self.balance_of(owner).sync.call().raw\n    result = self._get_debug_tracecall(\n        self.address,\n        data=f\"0x70a08231000000000000000000000000{owner.replace('0x', '')}\",\n    )\n    storage = result[self.address.lower()][\"storage\"]\n    for slot in storage:\n        if balance in storage[slot]:\n            return slot\n\n    # Unknown slot return None\n    return None\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.balance_state_diff","title":"balance_state_diff","text":"<pre><code>balance_state_diff(owner, balance)\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def balance_state_diff(\n    self, owner: primitives.address, balance: int\n) -&gt; Optional[dict]:\n    slot = self.get_balance_slot(owner)\n    if slot:\n        return {\n            self.address: {\n                \"stateDiff\": {\n                    slot: to_bytes32(balance),\n                },\n            },\n        }\n    return {}\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.allowance_state_diff","title":"allowance_state_diff","text":"<pre><code>allowance_state_diff(owner, spender, amount)\n</code></pre> Source code in <code>eth_typeshed/erc20/erc20.py</code> <pre><code>def allowance_state_diff(\n    self, owner: HexAddress, spender: HexAddress, amount: int\n) -&gt; Optional[dict]:\n    slot = self.get_allowance_slot(owner, spender)\n    if slot:\n        return {\n            self.address: {\n                \"stateDiff\": {\n                    slot: to_bytes32(amount),\n                }\n            },\n        }\n    return {}\n</code></pre>"},{"location":"api/typeshed/uniswap_v2/#eth_typeshed.uniswap_v2.UniswapV2Pair.get_price","title":"get_price","text":"<pre><code>get_price(token0=True)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v2/pair.py</code> <pre><code>def get_price(self, token0: bool = True):\n    reserves0, reserves1, _ = self.get_reserves().get()\n    price0, price1 = (reserves1 / reserves0, reserves0 / reserves1)\n    return Decimal(price0) if token0 else Decimal(price1)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/","title":"UniswapV3","text":""},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3","title":"eth_typeshed.uniswap_v3","text":""},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEvent","title":"V3PoolCreatedEvent  <code>module-attribute</code>","text":"<pre><code>V3PoolCreatedEvent = Event[V3PoolCreatedEventType](\n    name=\"PoolCreated\"\n)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEvent","title":"V3SwapEvent  <code>module-attribute</code>","text":"<pre><code>V3SwapEvent = Event[V3SwapEventType](name='Swap')\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NONFUNGIBLE_POSITION_MANAGER_ADDRESS","title":"NONFUNGIBLE_POSITION_MANAGER_ADDRESS  <code>module-attribute</code>","text":"<pre><code>NONFUNGIBLE_POSITION_MANAGER_ADDRESS = HexAddress(\n    HexStr(\"0xC36442b4a4522E871399CD717aBDD847Ab11FE88\")\n)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEventType","title":"V3PoolCreatedEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEventType.token0","title":"token0  <code>instance-attribute</code>","text":"<pre><code>token0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEventType.token1","title":"token1  <code>instance-attribute</code>","text":"<pre><code>token1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEventType.fee","title":"fee  <code>instance-attribute</code>","text":"<pre><code>fee\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEventType.tick_spacing","title":"tick_spacing  <code>instance-attribute</code>","text":"<pre><code>tick_spacing\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3PoolCreatedEventType.pool","title":"pool  <code>instance-attribute</code>","text":"<pre><code>pool\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType","title":"V3SwapEventType","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.sender","title":"sender  <code>instance-attribute</code>","text":"<pre><code>sender\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.recipient","title":"recipient  <code>instance-attribute</code>","text":"<pre><code>recipient\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.amount0","title":"amount0  <code>instance-attribute</code>","text":"<pre><code>amount0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.amount1","title":"amount1  <code>instance-attribute</code>","text":"<pre><code>amount1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.sqrt_price_x96","title":"sqrt_price_x96  <code>instance-attribute</code>","text":"<pre><code>sqrt_price_x96\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.liquidity","title":"liquidity  <code>instance-attribute</code>","text":"<pre><code>liquidity\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.V3SwapEventType.tick","title":"tick  <code>instance-attribute</code>","text":"<pre><code>tick\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.GetPoolRequest","title":"GetPoolRequest","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.GetPoolRequest.token_a","title":"token_a  <code>instance-attribute</code>","text":"<pre><code>token_a\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.GetPoolRequest.token_b","title":"token_b  <code>instance-attribute</code>","text":"<pre><code>token_b\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.GetPoolRequest.fee","title":"fee  <code>instance-attribute</code>","text":"<pre><code>fee\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory","title":"UniswapV3Factory","text":"<pre><code>UniswapV3Factory(**kwargs)\n</code></pre> <p>               Bases: <code>ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.get_pool","title":"get_pool  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_pool = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Factory.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager","title":"NonfungiblePositionManager","text":"<pre><code>NonfungiblePositionManager(**kwargs)\n</code></pre> <p>               Bases: <code>ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.balance_of","title":"balance_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>balance_of = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.token_of_owner_by_index","title":"token_of_owner_by_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token_of_owner_by_index = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.positions","title":"positions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positions = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.get_all_indices","title":"get_all_indices  <code>async</code>","text":"<pre><code>get_all_indices(owner)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/nonfungible_position_manager.py</code> <pre><code>async def get_all_indices(self, owner: HexAddress) -&gt; list[int]:\n    balance = await self.balance_of(OwnerRequest(owner=owner)).get()\n    calls = []\n    for i in range(balance):\n        calls.append(\n            self.token_of_owner_by_index(\n                OwnerTokenRequest(\n                    owner=owner,\n                    index=primitives.uint256(i),\n                )\n            )\n        )\n    return await multicall.execute(*calls)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.NonfungiblePositionManager.get_all_positions","title":"get_all_positions  <code>async</code>","text":"<pre><code>get_all_positions(owner)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/nonfungible_position_manager.py</code> <pre><code>async def get_all_positions(self, owner: HexAddress) -&gt; list[Position]:\n    indices = await self.get_all_indices(owner)\n    return await multicall.execute(\n        *[self.positions(primitives.uint256(index)) for index in indices]\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick","title":"ProcessedTick","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.tick","title":"tick  <code>instance-attribute</code>","text":"<pre><code>tick\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.token0","title":"token0  <code>instance-attribute</code>","text":"<pre><code>token0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.token1","title":"token1  <code>instance-attribute</code>","text":"<pre><code>token1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.active_liquidity","title":"active_liquidity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>active_liquidity = 0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.liquidity_net","title":"liquidity_net  <code>property</code>","text":"<pre><code>liquidity_net\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.price0","title":"price0  <code>property</code>","text":"<pre><code>price0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.ProcessedTick.price1","title":"price1  <code>property</code>","text":"<pre><code>price1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0","title":"Slot0","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.sqrt_price","title":"sqrt_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqrt_price = Field(serialization_alias='sqrtPriceX96')\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.tick","title":"tick  <code>instance-attribute</code>","text":"<pre><code>tick\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.observation_index","title":"observation_index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>observation_index = Field(\n    serialization_alias=\"observationIndex\"\n)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.observation_cardinality","title":"observation_cardinality  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>observation_cardinality = Field(\n    serialization_alias=\"observationCardinality\"\n)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.observation_cardinality_next","title":"observation_cardinality_next  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>observation_cardinality_next = Field(\n    serialization_alias=\"observationCardinality\"\n)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.fee_protocol","title":"fee_protocol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fee_protocol = Field(serialization_alias='feeProtocol')\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Slot0.unlocked","title":"unlocked  <code>instance-attribute</code>","text":"<pre><code>unlocked\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick","title":"Tick","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.liquidity_gross","title":"liquidity_gross  <code>instance-attribute</code>","text":"<pre><code>liquidity_gross\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.liquidity_net","title":"liquidity_net  <code>instance-attribute</code>","text":"<pre><code>liquidity_net\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.fee_growth_outside0","title":"fee_growth_outside0  <code>instance-attribute</code>","text":"<pre><code>fee_growth_outside0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.fee_growth_outside1","title":"fee_growth_outside1  <code>instance-attribute</code>","text":"<pre><code>fee_growth_outside1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.tick_cumulative_outside","title":"tick_cumulative_outside  <code>instance-attribute</code>","text":"<pre><code>tick_cumulative_outside\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.seconds_per_liquidity_outside","title":"seconds_per_liquidity_outside  <code>instance-attribute</code>","text":"<pre><code>seconds_per_liquidity_outside\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.seconds_outside","title":"seconds_outside  <code>instance-attribute</code>","text":"<pre><code>seconds_outside\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.Tick.initialized","title":"initialized  <code>instance-attribute</code>","text":"<pre><code>initialized\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool","title":"UniswapV3Pool","text":"<pre><code>UniswapV3Pool(**kwargs)\n</code></pre> <p>               Bases: <code>ProtocolBase</code></p> <p>This is how we make the ProtocolBase inject the ContractFunc via the type signature. After a lot of research, this goes slightly outside of the bounds for type hinting, but I think the improved expressiveness makes it fully worthwhile.</p> Source code in <code>eth_rpc/contract/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    This is how we make the ProtocolBase inject the ContractFunc via the type signature.\n    After a lot of research, this goes slightly outside of the bounds for type hinting,\n    but I think the improved expressiveness makes it fully worthwhile.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    for alias, func in self._func_sigs.items():\n        name = alias\n        if is_annotation(func):\n            annotation_args = get_args(func)\n            args = annotation_args[0]\n            for annotation in annotation_args:\n                if isinstance(annotation, Name):\n                    name = annotation.value\n        else:\n            args = func\n        T, U = get_args(args)\n\n        setattr(\n            self,\n            alias,\n            ContractFunc[T, U](  # type: ignore\n                func=FuncSignature[T, U](name=name, alias=alias),  # type: ignore\n                contract=self,\n            ),\n        )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.code_override","title":"code_override  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code_override = Field(default=None)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.functions","title":"functions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>functions = Field(default_factory=list)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.sync","title":"sync  <code>property</code>","text":"<pre><code>sync\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.tick_bitmap","title":"tick_bitmap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tick_bitmap = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.fee","title":"fee  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fee = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.slot0","title":"slot0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slot0 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.token0","title":"token0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token0 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.token1","title":"token1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token1 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.ticks","title":"ticks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ticks = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.liquidity","title":"liquidity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>liquidity = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.tick_spacing","title":"tick_spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tick_spacing = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.fee_growth_global0","title":"fee_growth_global0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fee_growth_global0 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.fee_growth_global1","title":"fee_growth_global1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fee_growth_global1 = METHOD\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> Source code in <code>eth_rpc/_request.py</code> <pre><code>def model_post_init(self, __context):\n    network = self.__class__._network\n    object.__setattr__(self, \"_network\", network)\n    # overwrite the .rpc() classmethod\n    object.__setattr__(self, \"rpc\", self._rpc)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.rpc","title":"rpc  <code>classmethod</code>","text":"<pre><code>rpc()\n</code></pre> <p>This uses the default network, unless a network has been provided</p> Source code in <code>eth_rpc/_request.py</code> <pre><code>@classmethod\ndef rpc(cls) -&gt; \"RPC\":\n    \"\"\"\n    This uses the default network, unless a network has been provided\n    \"\"\"\n    from ._transport import _force_get_global_rpc\n\n    if cls._network is None:\n        return _force_get_global_rpc()\n    response = _force_get_global_rpc(cls._network)\n    return response\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.add_func","title":"add_func","text":"<pre><code>add_func(func)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def add_func(self, func: \"FuncSignature\"):\n    if func not in self.functions:\n        self.functions.append(ContractFunc(func=func, contract=self))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_storage_at","title":"get_storage_at","text":"<pre><code>get_storage_at(*, slot, block_number='latest', sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_storage_at(\n    self, *, slot: int | HexStr, block_number=\"latest\", sync: bool = False\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_storage_at,\n        slot=slot,\n        block_number=block_number,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_code","title":"get_code","text":"<pre><code>get_code(*, block_number=None, block_hash=None, sync=False)\n</code></pre> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def get_code(\n    self,\n    *,\n    block_number: int | BLOCK_STRINGS | None = None,\n    block_hash: HexStr | None = None,\n    sync: bool = False,\n) -&gt; MaybeAwaitable[HexStr]:\n    return run(\n        self._get_code,\n        block_number=block_number,\n        block_hash=block_hash,\n        sync=sync,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.create2","title":"create2","text":"<pre><code>create2(salt, keccak_init_code)\n</code></pre> <p>EIP-104 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md</p> Source code in <code>eth_rpc/contract/contract.py</code> <pre><code>def create2(self, salt: bytes, keccak_init_code: bytes) -&gt; HexAddress:\n    \"\"\"\n    EIP-104\n    https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md\n    \"\"\"\n    pre = \"0xff\"\n    b_pre = bytes.fromhex(pre[2:])\n    b_address = bytes.fromhex(self.address[2:])\n\n    b_result = keccak_256(b_pre + b_address + salt + keccak_init_code)\n    result_address = \"0x\" + b_result[12:].hex()\n\n    return HexAddress(HexStr(result_address))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_price","title":"get_price  <code>async</code>","text":"<pre><code>get_price(token0=True)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_price(self, token0: bool = True):\n    slot0 = await self.slot0().get()\n    _token0 = await self.token0().get()\n    _token1 = await self.token1().get()\n    token0_decimals = await ERC20(address=_token0).decimals().get()\n    token1_decimals = await ERC20(address=_token1).decimals().get()\n    return self.sqrt_price_x96_to_token_prices(\n        slot0.sqrt_price,\n        token0_decimals,\n        token1_decimals,\n        token0,\n    )\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.sqrt_price_x96_to_token_prices","title":"sqrt_price_x96_to_token_prices  <code>staticmethod</code>","text":"<pre><code>sqrt_price_x96_to_token_prices(\n    sqrt_price_x96,\n    token0_decimals,\n    token1_decimals,\n    token0=True,\n)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>@staticmethod\ndef sqrt_price_x96_to_token_prices(\n    sqrt_price_x96: int,\n    token0_decimals: int,\n    token1_decimals: int,\n    token0: bool = True,\n) -&gt; Decimal:\n    num = Decimal(sqrt_price_x96 * sqrt_price_x96)\n    price1 = (\n        (num / Q192)\n        * (Decimal(10) ** token0_decimals)\n        / (Decimal(10) ** token1_decimals)\n    )\n    price0 = Decimal(1) / price1\n\n    return price0 if token0 else price1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.all_tick_values","title":"all_tick_values  <code>async</code>","text":"<pre><code>all_tick_values()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def all_tick_values(self):\n    tick_spacing = await self.get_tick_spacing()\n    min_tick, max_tick = await self.tick_range()\n    return list(range(min_tick, max_tick, tick_spacing))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_token0","title":"get_token0  <code>async</code>","text":"<pre><code>get_token0()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_token0(self):\n    if not self._token0:\n        self._token0 = ERC20(await self.token0().get())\n    return self._token0\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_token1","title":"get_token1  <code>async</code>","text":"<pre><code>get_token1()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_token1(self):\n    if not self._token1:\n        self._token1 = ERC20(await self.token1().get())\n    return self._token1\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_tick_spacing","title":"get_tick_spacing  <code>async</code>","text":"<pre><code>get_tick_spacing()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_tick_spacing(self):\n    if not self._tick_spacing:\n        self._tick_spacing = await self.tick_spacing().get()\n    return self._tick_spacing\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_swaps","title":"get_swaps  <code>async</code>","text":"<pre><code>get_swaps(start_block, end_block)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_swaps(\n    self, start_block, end_block\n) -&gt; dict[int, list[V3SwapEventType]]:\n    ticks: dict[int, list[V3SwapEventType]] = {}\n    tick_values = await self.all_tick_values()\n    async for event in V3SwapEvent.set_filter(addresses=[self.address]).backfill(\n        start_block, end_block\n    ):\n        tick = event.event.tick\n        closest_tick = max(t for t in tick_values if t &lt;= tick)\n        if tick in ticks:\n            ticks[closest_tick].append(event.event)\n        else:\n            ticks[closest_tick] = [event.event]\n    return ticks\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_ticks","title":"get_ticks  <code>async</code>","text":"<pre><code>get_ticks(indices)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_ticks(self, indices: Iterable[int]) -&gt; list[ProcessedTick]:\n    calls = []\n    for tick in indices:\n        calls.append(self.ticks(primitives.int24(tick)))\n    ticks: list[Tick] = await multicall.execute(*calls)\n\n    processed_ticks = []\n    for idx, tick_data in zip(indices, ticks):\n        processed_ticks.append(\n            ProcessedTick(\n                index=idx,\n                tick=tick_data,\n                token0=await self.get_token0(),\n                token1=await self.get_token1(),\n            )\n        )\n    return processed_ticks\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.tvl","title":"tvl  <code>async</code>","text":"<pre><code>tvl(block_number=None)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def tvl(self, block_number=None) -&gt; list[ProcessedTick]:\n    liquidity, initialized_ticks, active_tick_index = await asyncio.gather(\n        self.liquidity().get(),\n        self.get_initialized_ticks(),\n        self.active_tick(),\n    )\n    ticks = await self.get_ticks(initialized_ticks)\n\n    if active_tick_index in initialized_ticks:\n        active_tick = [t for t in ticks if t.index == active_tick_index][0]\n        active_tick.active_liquidity = liquidity\n        current_liquidity = liquidity - active_tick.liquidity_net\n        previous_tick_net = active_tick.liquidity_net\n    else:\n        current_liquidity = liquidity\n        previous_tick_net = 0\n\n    for tick in [tick for tick in ticks if tick.index &lt; active_tick_index][::-1]:\n        tick.active_liquidity = current_liquidity - previous_tick_net\n        current_liquidity = tick.active_liquidity\n        previous_tick_net = tick.liquidity_net\n\n    current_liquidity = liquidity\n    previous_tick_net = 0\n    for tick in [tick for tick in ticks if tick.index &gt; active_tick_index]:\n        tick.active_liquidity = current_liquidity + tick.liquidity_net\n        current_liquidity = tick.active_liquidity\n    return ticks\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_tick_range","title":"get_tick_range  <code>async</code>","text":"<pre><code>get_tick_range(lower, upper)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_tick_range(self, lower: int, upper: int) -&gt; list[ProcessedTick]:\n    if not self._tick_spacing:\n        self._tick_spacing = await self.tick_spacing().get()\n    assert self._tick_spacing\n    return await self.get_ticks(range(lower, upper, self._tick_spacing))\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.tick_range","title":"tick_range  <code>async</code>","text":"<pre><code>tick_range()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def tick_range(self):\n    tick_spacing = await self.get_tick_spacing()\n    min_tick = math.ceil(MIN_TICK / tick_spacing) * tick_spacing\n    return min_tick, -min_tick\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.bitmap_range","title":"bitmap_range  <code>async</code>","text":"<pre><code>bitmap_range()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def bitmap_range(self) -&gt; tuple[int, int]:\n    min_tick, max_tick = await self.tick_range()\n    return (min_tick // 60 // 256), (max_tick // 60 // 256)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_initialized_ticks","title":"get_initialized_ticks  <code>async</code>","text":"<pre><code>get_initialized_ticks()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_initialized_ticks(self) -&gt; list[int]:\n    min_bitmap, max_bitmap = await self.bitmap_range()\n    tick_spacing = await self.get_tick_spacing()\n    bitmaps = await multicall.execute(\n        *[\n            self.tick_bitmap(primitives.int16(idx))\n            for idx in range(min_bitmap, max_bitmap + 1)\n        ]\n    )\n    initialized_ticks = []\n    for idx, row in zip(range(min_bitmap, max_bitmap + 1), bitmaps):\n        initialized_ticks.extend(tick_from_bitmap(idx, row, tick_spacing))\n    return initialized_ticks\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.active_tick","title":"active_tick  <code>async</code>","text":"<pre><code>active_tick()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def active_tick(self) -&gt; int:\n    slot0 = await self.slot0().get()\n    if not self._tick_spacing:\n        self._tick_spacing = await self.tick_spacing().get()\n    return slot0.tick // self._tick_spacing * self._tick_spacing\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.liquidity_at_current_tick","title":"liquidity_at_current_tick  <code>async</code>","text":"<pre><code>liquidity_at_current_tick(tick)\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def liquidity_at_current_tick(self, tick: int) -&gt; tuple[float, float]:\n    tick_spacing, slot0, liquidity = cast(\n        tuple[int, Slot0, int],\n        await multicall.execute(\n            self.tick_spacing(),\n            self.slot0(),\n            self.liquidity(),\n        ),\n    )\n    bottom_tick = tick\n    top_tick = tick + tick_spacing\n\n    price = tick_to_price(slot0.tick)\n    sa = tick_to_price(bottom_tick // 2)\n    sb = tick_to_price(top_tick // 2)\n    sqrt_price = math.sqrt(price)\n\n    amount0 = liquidity * (sb - sqrt_price) / (sqrt_price * sb)\n    amount1 = liquidity * (sqrt_price - sa)\n\n    return (amount0, amount1)\n</code></pre>"},{"location":"api/typeshed/uniswap_v3/#eth_typeshed.uniswap_v3.UniswapV3Pool.get_all_positions","title":"get_all_positions  <code>async</code>","text":"<pre><code>get_all_positions()\n</code></pre> Source code in <code>eth_typeshed/uniswap_v3/pool.py</code> <pre><code>async def get_all_positions(self):\n    events = []\n    async for event in V3MintEvent.set_filter(addresses=[self.address]).backfill():\n        events.append(event.event)\n    return events\n</code></pre>"},{"location":"getting-started/","title":"QUICK START","text":"<p>install using pip</p> <pre><code>pip install eth-rpc-py\npip install eth-typeshed-py\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>We recommend setting up an Alchemy account so you can utilize your API key for requests, otherwise you will use public RPCs that typically do not allow for websocket connections or frequent requests.  You can also set your RPC directly</p> <pre><code>import os\n\nfrom eth_rpc import set_alchemy_key, set_rpc_url\nfrom eth_rpc.networks import Ethereum\n\n# If you want to set an RPC for a network directly\nset_rpc_url(Ethereum, os.environ[\"MY_PRIVATE_RPC_URL\"])\n\n# Or you can set your alchemy key and it will automatically set it as the default RPC for all networks\nset_alchemy_key(os.environ[\"ALCHEMY_KEY\"])\n</code></pre>"},{"location":"getting-started/account/","title":"Account Class","text":"<p>The Account class is part of the eth_rpc package and provides methods for interacting with Ethereum accounts via RPC calls.</p> <pre><code>from eth_rpc import Account\n\neth_address = \"0x0000000000000000000000000000000000000000\"\n# get an account's balance\nbalance = await Account.get_balance(eth_address)\n\n# Get all account data\naccount_data = await Account.get_account(eth_address)\n\n# Access and display individual fields\nprint(f\"Account Details for {eth_address}:\")\nprint(f\"Balance: {account_data.balance} wei\")\nprint(f\"Nonce: {account_data.nonce}\")\nprint(f\"Code Hash: {account_data.code_hash}\")\nprint(f\"Storage Root: {account_data.storage_root}\")\n\n# Convert balance to Ether for better readability\nbalance_in_ether = int(account_data.balance, 16) / 1e18\nprint(f\"Balance in Ether: {balance_in_ether:.6f} ETH\")\n\n# Check if the account is a contract\nis_contract = account_data.code_hash != \"0x0000000\"\nprint(f\"Is Contract: {'Yes' if is_contract else 'No'}\")\n</code></pre> <p>Warning</p> <p><code>get_account</code> will not work on the Alchemy RPC; it does not support the <code>eth_getAccount</code> method.  It will work with quicknode and some other RPC providers.</p>"},{"location":"getting-started/blocks/","title":"Blocks","text":"<p>The Block class is your connection to the different RPC endpoints that are specific to Blocks onchain.  Typically you will want to check things like the current block number, or you might want to access all the transactions for a specific block.</p> <p>The returned <code>Block</code> is a Pydantic BaseModel, providing typed access to all associated fields.</p> <pre><code>from eth_rpc import Block\n\nblock = await Block.load_by_number(3_000_000)\n</code></pre> <p>If you want to load with transactions, just specify in the request:</p> <pre><code>from eth_rpc import Block, Transaction\n\nblock = await Block.load_by_number(3_000_000, with_tx_data=True)\ntransactions: list[Transaction] = block.transactions\n</code></pre> <p>Now we have access to a Transaction, which is also a Pydantic BaseModel, and it exposes the ability to access it's <code>TransactionReceipt</code>.  So similar to an ORM, all the different types are able to communicate with the RPC in a meaningful way.</p> <pre><code>tx = transactions[0]\nawait tx.receipt()\n</code></pre>"},{"location":"getting-started/blocks/methods/","title":"Blocks RPC Methods","text":""},{"location":"getting-started/blocks/methods/#fee-history","title":"Fee History","text":"<p>We can also load the FeeHistory for a series of blocks to help plan our transaction:</p> <pre><code>fee_history = await Block.fee_history(\n    block_count=4,\n    lower_percentile=25,\n    upper_percentile=75,\n    block_number=20_000_000,  # by default this is set to \"latest\"\n)\n# fee_history.base_fee_per_gas == [5104157871, 5171340881, 5004025121, 4936957716, 4776082506]\n</code></pre> <p>This shows the base_fee_per_gas for the last four blocks, so you can accurately estimate the minimum base_fee_per_gas needed for a transaction.</p>"},{"location":"getting-started/blocks/methods/#subscription","title":"Subscription","text":"<p>We can utilize the RPC websocket endpoint to connect and subscribe to blocks as they are ingested.  You can also backfill from a certain block number, which is useful when you have a persistent stream and want to be able to resume from a certain number.</p> <pre><code>async for block in Block.subscribe_from(20_000_000):\n    # print the number and their tx count\n    print(block.number, len(block.transactions))\n</code></pre>"},{"location":"getting-started/blocks/methods/#additional-methods","title":"Additional Methods","text":"<p>There are a few other methods supported by most RPCs that are blocks related:</p> <pre><code>from eth_typing import HexStr\n\nawait Block.get_block_transaction_count(20_000_000)\nawait Block.load_by_number(20_000_000, with_tx_data=False)\nawait Block.get_number()  # get current block number\nawait Block.latest()\nawait Block.pending()\nawait Block.load_by_hash(\n    HexStr(\n        \"0x13ced9eaa49a522d4e7dcf80a739a57dbf08f4ce5efc4edbac86a66d8010f693\"\n    )\n)\n</code></pre>"},{"location":"getting-started/blocks/model/","title":"The Blocks Model","text":"<p><code>Block</code> is a Pydantic BaseModel.  It has all the fields provided by the standard Ethereum RPC.</p> <pre><code>class Block(RPCModel):\n    number: HexInteger\n    hash: Optional[HexStr] = None\n    base_fee_per_gas: Optional[HexInteger] = None\n    transactions: list[\"Transaction\"] | list[HexStr] = Field(default_factory=list)\n    difficulty: HexInteger\n    extra_data: HexStr\n    gas_limit: HexInteger\n    gas_used: HexInteger\n    logs_bloom: HexStr\n    miner: Optional[HexAddress] = None\n    mix_hash: HexStr\n    nonce: Optional[HexStr] = None\n    parent_hash: HexStr\n    receipts_root: HexStr\n    sha3_uncles: HexStr\n    size: HexInteger\n    state_root: HexStr\n    timestamp: datetime\n    total_difficulty: Optional[HexInteger] = None\n    transactions_root: HexStr\n    uncles: list[HexStr] = Field(default_factory=list)\n</code></pre> <p>Tip</p> <p>The block will either have a list of Transaction hashes or a list of Transactions, depending on whether or not you request the block <code>with_tx_data=True</code>.  By default it returns the transaction hashes.</p>"},{"location":"getting-started/contracts/","title":"Contracts","text":""},{"location":"getting-started/contracts/#contract-class","title":"Contract Class","text":"<p>The Contract class is a fundamental component in our system, representing a smart contract on the blockchain. It provides a typed, structured way to interact with and manage onchain contract interactions.</p>"},{"location":"getting-started/contracts/#overview","title":"Overview","text":"<p>A <code>Contract</code> instance encapsulates the following key elements:</p> <ul> <li>Contract address</li> <li>Contract Interface</li> </ul>"},{"location":"getting-started/contracts/#key-features","title":"Key Features","text":"<ol> <li>Method Invocation: Call contract methods easily.</li> <li>Event Listening: Subscribe to and handle contract events.</li> <li>State Reading: Read the current state of the contract.</li> <li>Transaction Sending: Send transactions to modify the contract state.</li> </ol>"},{"location":"getting-started/contracts/#basic-usage","title":"Basic Usage","text":"<p>The real focus is on making it easier to interact with deployed smart contracts and having some greater type safety.  For example, say you want to interact with a contract you just deployed, ie:</p> <pre><code>contract MyContract {\n    function foo(address[] users) external returns(bool success) {}\n}\n</code></pre> <p>Rather than copying the abi into a JSON file, you can create a typed contract interface:</p> <pre><code>from typing import Annotated\n\nfrom eth_rpc.contract import ProtocolBase, ContractFunc\nfrom eth_rpc import Transaction\nfrom eth_rpc.wallet import PrivateKeyWallet\nfrom eth_rpc.types import HexStr, Name, primitives\n\n\nclass MyContract(ProtocolBase):\n    foo: ContractFunc[\n        list[primitives.address],  # input type is a list of addresses\n        Annotated[bool, Name(\"success\")],  # response type is a boolean\n    ] = METHOD # this is necessary for the type checker to recognize it as a contract method\n\ncontract = MyContract(address=\"&lt;Contract Address&gt;\")\n# create a wallet for yourself\nwallet = PrivateKeyWallet(private_key=os.environ[\"PK\"])\n\n# call it without execution:\nresponse: bool = await contract.foo(['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', ...]).call(\n    from_=wallet.address,\n)\n\n# or call it with execution:\ntx_hash: HexStr = await contract.foo(['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', ...]).execute(wallet)\ntx: Transaction[Ethereum] = await Transaction[Ethereum].get_by_hash(tx_hash)\n</code></pre>"},{"location":"getting-started/contracts/codegen/","title":"Codegen: Streamlining Contract Interactions","text":"<p>While the approach described earlier might appear to involve substantial boilerplate code, it offers significant advantages in terms of code quality, maintainability, and developer experience:</p> <ol> <li> <p>Enhanced Type Safety: The system provides immediate error notifications for type mismatches, reducing runtime errors and improving code reliability.</p> </li> <li> <p>Improved Readability: The structured format is more easily interpretable, not just for developers but also for Large Language Models, facilitating better code analysis and generation.</p> </li> <li> <p>Typed Responses: This approach delivers typed responses, enabling more robust and predictable code interactions.</p> </li> <li> <p>Reduced Dependency: Unlike traditional methods, this approach eliminates the need for importing large JSON files, leading to more efficient and cleaner codebases.</p> </li> <li> <p>Easy Generation: Despite its apparent complexity, this code can be automatically generated from the contract's ABI (Application Binary Interface), significantly reducing manual effort.</p> </li> <li> <p>AI-Assisted Enhancement: Leveraging AI models like OpenAI's GPT-4 or Anthropic's Claude, we can generate not only the typed bindings from the ABI but also comprehensive documentation and meaningful variable names for any verified contract.</p> </li> </ol> <p>This approach strikes a balance between initial setup and long-term benefits, providing a robust foundation for interacting with smart contracts in a type-safe and efficient manner.</p> <p>Note</p> <p>We are in the process of open-sourcing our codegen tooling. This documentation serves dual purposes: to guide users and to improve indexing and understanding by popular AI models, enhancing future code generation capabilities.</p>"},{"location":"getting-started/contracts/func/","title":"Contract Function Types","text":"<p>When building a contract function, you can utilize a variety of pythonic concepts to define your signature to be as easy to manipulate as possible.  Firstly, if you need to define a solidity <code>struct</code> you can utilize the <code>eth_rpc.types.Struct</code> class, and define your model inheriting from this class.  For example, if you had a smart contract with a function like:</p> <p>Note</p> <p>This is not a realistic function signature, but it showcases multiple features of the ContractFunc class</p> <pre><code>contract ExampleContract {\n    enum Status {\n        SUCCESS,\n        FAILURE\n    }\n\n    struct Account {\n        uint256 accountId;\n        uint256 balance;\n        bool isActive;\n    }\n\n    struct Transaction {\n        uint256 recipientId;\n        uint256 amount;\n    }\n\n    struct DepositResult {\n        int256 balanceUpdate;\n        Status status;\n    }\n\n    function depositFunds(Account memory account, Transaction[] memory transactions, uint256 deadline, bytes[] memory additionalArgs) external returns(bool success, DepositResult memory) {\n        ...\n    }\n}\n</code></pre> <p>So this method, <code>depositFunds</code>, has a few characteristics.  It takes multiple structs, one as a direct argument and the other as a list of structs.  It also returns multiple values, one with an Enum field.  Now we can translate this directly to python types.</p>"},{"location":"getting-started/contracts/func/#basic-imports","title":"Basic Imports","text":"<pre><code>from enum import IntEnum  # Its best to use IntEnum, since your enum fields need to be indexed from 0\nfrom typing import Annotated  # This is used to attach additional information to fields\n\n# this is used to wrap the Input/Output class of the ContractFunc\nfrom pydantic import BaseModel\n\n# these are the main types used in building a Contract\nfrom eth_rpc import ContractFunc, ProtocolBase, Struct\nfrom eth_rpc.types import METHOD, primitives\n</code></pre>"},{"location":"getting-started/contracts/func/#struct-definitions","title":"Struct Definitions","text":"<p>Then we can define the internal types.  The <code>Status</code> Enum and the <code>Account</code> and <code>Transaction</code> Structs.  You need to define your fields as primitives/Structs, with the exception of bool and bytes.  Likewise if there are no args or return type you can provide <code>None</code> to indicate this.  Make sure to use the <code>Struct</code> type when referring to an onchain <code>Struct</code> or <code>tuple</code>, this helps the encoder/decoder to understand the onchain structure of the function.</p> <pre><code>class Status(IntEnum):\n    SUCCESS = 0\n    FAILURE = 1\n\n\nclass Account(Struct):\n    account_id: Annotated[\n        primitives.uint256,\n        Name(\"accountId\"),\n    ]\n    balance: primitives.uint256\n    is_active: Annotated[\n        bool,\n        Name(\"isActive\"),\n    ]\n\nclass Transaction(Struct):\n    recipient_id: Annotated[\n        primitives.uint256,\n        Name(\"recipientId\"),\n    ]\n    amount: primitives.uint256\n\n\nclass DepositResult(Struct):\n    balance_updated: Annotated[\n        primitives.int256,\n        Name(\"balanceUpdate\"),\n    ]\n    status: Status\n</code></pre>"},{"location":"getting-started/contracts/func/#defining-the-input-and-output-types","title":"Defining the Input and Output types","text":"<p>Then we can define the objects for the Request and Response types.  Notice these are not <code>Struct</code>s.  That is because the encoder for a contract will encode a <code>Struct</code> argument differently from a list of parameters.  This is by design, so ensure you are only using <code>Struct</code>s to abstract actual struct types.</p> <p>For functions that take a single argument, you can provide the raw type.  For example, you could define a function <code>balance: ContractFunc[primitives.address, primitives.uint256]</code> for a function that takes an <code>address</code> as an argument and returns a <code>uint256</code>.</p> <pre><code>class DepositRequest(BaseModel):\n    account: Account\n    txs: list[Transaction]\n    deadline: primitives.uint256\n    additional_args: Annotated[\n        list[bytes],\n        Name(\"additionalArgs\"),\n    ]\n\n\nclass DepositResponse(BaseModel):\n    success: bool\n    result: DepositResult\n</code></pre>"},{"location":"getting-started/contracts/func/#building-the-contract","title":"Building the Contract","text":"<p>With our types defined, we can now define the function <code>depositFunds</code> as a python function with type hints.  The <code>METHOD</code> is important because it indicates to the type checker this function does not require initialization.  If you change from CamelCase to snake_case, make sure to annotate the function with its name onchain, as this is used to calculate the function selector.</p> <pre><code>class ExampleContract(ProtocolBase):\n    deposit_funds: Annotated[\n        ContractFunc[\n            DepositRequest,\n            DepositResponse,\n        ],\n        Name(\"depositFunc\"),\n     ] = METHOD\n\ncontract = ExampleContract(address=contract_address)\n\n# this response object is now parsed back into a DepositResponse\nresponse: DepositResponse = await contract.deposit_funds(\n    DepositRequest(\n        account=Account(account_id=1, balance=100, is_active=True),\n        deadline=primitives.uint256(12345),\n        additional_args=[b'123', b'456'],\n    )\n).get()\n</code></pre>"},{"location":"getting-started/events/","title":"Events","text":"<p>The Event class in <code>packages/eth_rpc/src/eth_rpc/event.py</code> is a crucial component for handling Ethereum events. Here's an overview of its functionality and usage:</p>"},{"location":"getting-started/events/#event-class","title":"Event Class","text":"<p>The <code>Event</code> class is a Generic class representing an Ethereum event and provides methods to interact with it.  In order to define the schema of the event, you need to define a pydantic class with the appropriate fields, annotated with <code>Indexed</code> when necessary.</p> <pre><code>from typing import Annotated\n\nfrom eth_rpc import Event\nfrom eth_rpc.types import Indexed\nfrom pydantic import BaseModel\n\nclass V2SwapEventType(BaseModel):\n    sender: Annotated[primitives.address, Indexed]\n    amount0_in: primitives.uint256\n    amount1_in: primitives.uint256\n    amount0_out: primitives.uint256\n    amount1_out: primitives.uint256\n    to: Annotated[primitives.address, Indexed]\n</code></pre>"},{"location":"getting-started/events/#subscription","title":"Subscription","text":"<p>You can define an event by creating a BaseModel that defines the event's interface, and then creating an Event instance that has the Event Type as a Generic Argument.  The async generator will yield EventData, where the type of the event is the Generic type applied when the Event was initialized.  For example:</p> <pre><code># This will yield EventData[V2SwapEventType] when you subscribe\nV2SwapEvent = Event[V2SwapEventType](name=\"Swap\")\n</code></pre> <p>Then, you are able to use this event to index, filter and decode logs.  For example:</p> <pre><code># Create an event filter for the V2SwapEvent\n# Set up a filter for the V2SwapEvent, specifying the contract address\nevent_filter = V2SwapEvent.set_filter(\n    addresses=[\"0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852\"]\n)\n\n# Use an asynchronous for loop to iterate over the event subscriber\nasync for event_data in event_filter.subscribe():\n    # event_data contains two main components:\n    # 1. The raw log data\n    log: Log = event_data.log\n    # 2. The decoded event data as an instance of V2SwapEventType\n    event: V2SwapEventType = event_data.event\n\n    # You can access other fields similarly:\n    print(f\"Sender: {event.sender}\")\n    print(f\"To: {event.to}\")\n    print(f\"Amount 0 In: {event.amount0_in}\")\n    print(f\"Amount 1 In: {event.amount1_in}\")\n    print(f\"Amount 0 Out: {event.amount0_out}\")\n    print(f\"Amount 1 Out: {event.amount1_out}\")\n\n    You can also access raw log data if needed:\n    print(f\"Block Number: {log.block_number}\")\n    print(f\"Transaction Hash: {log.transaction_hash}\")\n</code></pre>"},{"location":"getting-started/events/#backfill","title":"Backfill","text":"<p>This is also useful for backfilling data for an event within a historical range.  For example:</p> <pre><code>from eth_rpc.utils import address_to_topic\n\nclass TransferEventType(BaseModel):\n    sender: Annotated[primitives.address, Indexed]\n    recipient: Annotated[primitives.address, Indexed]\n    amount: primitives.uint256\n\n# Create an event filter for the TransferEvent\nTransferEvent = Event[TransferEventType](name=\"Transfer\")\n\n# Set up a filter for the TransferEvent, specifying the topic1 filter.\n# This makes the subscription only return events with the sender specified.\nevent_filter = TransferEvent.set_filter(\n    topic1=address_to_topic(\"0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8\"),\n)\n\n# Use an asynchronous for loop to iterate over the event subscriber\n# This will yield EventData[TransferEvent]\nasync for event_data in event_filter.backfill(start_block=16_000_000, end_block=18_000_000):\n    # event_data contains two main components:\n    # 1. The raw log data\n    log: Log = event_data.log\n    # 2. The decoded event data as an instance of V2SwapEventType\n    event: V2SwapEventType = event_data.event\n</code></pre>"},{"location":"getting-started/transactions/","title":"Transactions","text":"<p>The Transaction class abstracts all requests related to Ethereum Transactions.  With the transactions model you can access Transactions and TransactionReceipts.</p> <pre><code>from eth_typing import HexStr\n\nfrom eth_rpc import Transaction, TransactionReceipt\n\n\ntx_hash: HexStr = HexStr(\n    \"0x5c504ed432cb51138bcf09aa5e8a410dd4a1e204ef84bfed1be16dfba1b22060\"\n)\n\ntx: Transaction = await Transaction.get_by_hash(tx_hash)\n# get the receipt\ntx_reciept: TransactionReceipt = await Transaction.get_receipt_by_hash(tx.hash)\n\n# you can also access the receipt directly from the tx object\ntx_receipt: TransactionReceipt = await tx.receipt()\n\n# you can get a transaction from a block by its index\ntx: Transaction = await Transaction.get_by_index(\n    transaction_index=0,\n    block_hash=HexStr(\n        \"0x4e3a3754410177e6937ef1f84bba68ea139e8d1a2258c5f85db9f1cd715a1bdd\",\n    ),\n)\n</code></pre>"},{"location":"getting-started/transactions/#pending-transactions","title":"Pending Transactions","text":"<p>You can also load pending transactions by hash, from a mempool monitor</p> <pre><code># subscribe to all pending transactions, and print the hash\nasync for tx in Transaction.subscribe_pending():\n    print(tx.hash)\n</code></pre>"},{"location":"getting-started/transactions/#getting-a-transactions-block","title":"Getting a transactions block","text":"<p>You can access the transactions block by calling the <code>get_block</code> method on a transaction object.  As usual, <code>with_tx_data</code> is an optional argument.</p> <pre><code>tx: Transaction = await Transaction.get_by_hash(tx_hash)\nblock: Block = await tx.get_block(with_tx_data=True)\n</code></pre>"},{"location":"getting-started/transactions/model/","title":"Transaction Model","text":"<p>Transaction and TransactionReceipt are both Pydantic BaseModels.  It has all the fields provided by the standard Ethereum RPC.</p> <pre><code>class Transaction(BaseModel):\n    hash: HexStr\n    access_list: Optional[list[AccessList]] = None\n    chain_id: Optional[HexInteger] = None\n    from_: HexStr = Field(alias=\"from\")\n    gas: HexInteger\n    gas_price: HexInteger\n    max_fee_per_gas: Optional[HexInteger] = None\n    max_priority_fee_per_gas: Optional[HexInteger] = None\n    input: HexStr\n    nonce: HexInteger\n    r: HexStr\n    s: HexStr\n    v: HexInteger\n    to: Optional[HexStr]\n    type: Optional[HexInteger] = None\n    value: HexInteger\n    y_parity: HexInteger | None = None\n    block_hash: HexStr\n    block_number: HexInteger\n    transaction_index: HexInteger\n\n\nclass TransactionReceipt(BaseModel):\n    transaction_hash: HexStr\n    block_hash: HexStr\n    block_number: HexInteger\n    logs: list[Log]\n    contract_address: Optional[HexStr]\n    effective_gas_price: HexInteger\n    cumulative_gas_used: HexInteger\n    from_: HexAddress = Field(alias=\"from\")\n    gas_used: HexInteger\n    logs_bloom: HexInteger\n    status: Optional[HexInteger] = None\n    to: Optional[HexAddress]\n    transaction_index: HexInteger\n    type: HexInteger\n</code></pre>"},{"location":"getting-started/transport/","title":"Transport","text":"<p>There are a few ways to manage RPC connections.  The simplest way is to set your alchemy api key, and it will automatically use Alchemy RPC's for your connections.  This is useful when doing indexing, but sometimes you may need a private RPC or a specific RPC for a network.  In those cases, you can set the RPC like this:</p> <pre><code>from eth_rpc import set_rpc_url\nfrom eth_rpc.networks import Ethereum  # this can be any network\n\nset_rpc_url(Ethereum, http=\"http://my_rpc.com\", wss=\"wss://my_rpc.com\")\n</code></pre>"},{"location":"getting-started/transport/#setting-alchemy","title":"Setting Alchemy","text":"<p>Alchemy is a popular RPC node provider that supports many networks.  They will always be the same url for an account, and so if you provide an API key the library is able to use your alchemy RPC url by default:</p> <pre><code>from eth_rpc import set_alchemy_key\n\nset_alchemy_key(\"&lt;ALCHEMY_KEY&gt;\")\n</code></pre>"},{"location":"getting-started/transport/#networks","title":"Networks","text":"<p>The Network Class must be implemented for each network you want to interact with.  This is because the Network must be a singleton, and it must be a proper Type so it's compatbile with Generics.  The only mutable fields on the Network class should be the rpc nodes.  This allows you to globally set the desired rpc for a network.</p> <p>If you need to add a network that is not supported, please make a Pull Request!  But this is not necessary, you can simply implement the Network class.  For example, here's the implementtion for a made up network:</p> <pre><code>class MyPrivateNetwork(Network):\n    chain_id: ClassVar[int] = 12345\n    name: ClassVar[str] = \"My Private Network\"\n    native_currency: ClassVar[str] = \"MPN\"\n    rpc: ClassVar[Rpcs] = Rpcs(\n        default=RpcUrl(\n            http=Url(\"https://my-private.network\"),\n            http=\"wss://my-private.network\",\n        )\n    )\n    block_explorer: ClassVar[BlockExplorer] = BlockExplorer(\n        name=\"MpnScan\",\n        url=\"https://mpnscan.org\",\n        api_url=\"https://api.mpnscan.org/api\",\n    )\n    alchemy_str: ClassVar[str | None] = None\n    apprx_block_time: ClassVar[float] = 1.23\n</code></pre> <p>Then you can use this just like the other networks, or even set it as your default network via:</p> <pre><code>from eth_rpc import set_default_network\n\nset_default_network(MyPrivateNetwork)\n</code></pre>"},{"location":"typeshed/","title":"eth-typeshed","text":"<p>A collection of typed bindings to popular smart contracts, with contract addresses and other data for easy reference.</p>"},{"location":"typeshed/#example","title":"Example","text":"<pre><code>from eth_typeshed import ERC20\n\nusdt = ERC20(address=usdt_address)\nawait usdt.transfer(TransferRequest(\n    recipient=\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\",\n    amount=int(1e6),\n))\n</code></pre>"}]}